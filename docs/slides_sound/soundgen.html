<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>slides_sound.soundgen API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>slides_sound.soundgen</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/python -u
import math
import wave
from .notes import notes, scale, chord, C, N, S, Song, duration, chord2scales, split_chord, join_chord, init_sample_cache, init_sample_cache_sf, find_default_soundfont, get_cached_sample, closest_index_in_scale, total_time
import time
import re
import random
import sys

# Tempo in bpm
tempo = 120
global_max_amp = 15386.00
phrase_measures = random.choice([2,4,8])
verbose = False
debug = False
random.seed()

value_to_eighths = {
    1.5:12,
    1:8,
    2.5:6,
    2:4,
    4.5:3,
    4:2,
    8:1
    }

eighths_to_value = {
    12:1.5,
    8:1,
    6:2.5,
    4:2,
    3:4.5,
    2:4,
    1:8
    }

note_lengths = [0,8,8,8,4,4,4,2,1]
times = [0,1,1,1,2,2,2,4,8]
bass_note_lengths = [0,8,4,4,4,2,2,2,1]
bass_times = [0,1,2,2,2,4,4,4,8]


class DeltaGenerator:
    def __init__(self, deltas = [] ):
        self.deltas = deltas
        self.didx = 0

    def getDelta( self ):
        delta = 0
        if self.deltas:
            delta = self.deltas[self.didx]
            self.didx = self.didx + 1
            if self.didx &gt;= len(self.deltas):
                self.didx = 0
        return delta

def sum_eighths( line ):
    eighths = 0
    for s in line:
        eighths += value_to_eighths[s.value]
    return eighths

def load_music( music_file ):
    s = open(music_file,&#34;r&#34;).read()
    return eval(s)

def set_verbose( vb ):
    global verbose
    verbose = vb

def set_debug( db ):
    global debug
    debug = db

def save_sample ( output, fname, channels ):
    out_file = wave.open(fname,&#34;w&#34;)
    out_file.setparams((channels,2,44100,len(output)//2,&#34;NONE&#34;,&#34;noncompressed&#34;))
    out_file.writeframes(output)
    out_file.close()

def unpack_sample( s ):
    sl = len(s)//2
    up = wave.struct.unpack_from(&#39;%dh&#39;%sl,s,0)
    us = [float(sv) for sv in up]
    return us

def unpack_channels( s ):
    up = unpack_sample(s)
    left = []
    right = []
    idx = 0
    while idx &lt; len(up)-1:
        left.append(up[idx])
        right.append(up[idx+1])
        idx += 2
    return left,right

def pack_channels( left, right ):
    idx = 0
    both = []
    while idx &lt; len(left):
        both.append(left[idx])
        both.append(right[idx])
        idx += 1
    return pack_sample(both)

def pack_sample( s ):
    sample = bytearray(len(s)*2)
    wave.struct.pack_into(&#39;%dh&#39;%len(s),sample,0,*[int(sv) for sv in s])
    return sample

def max_sample( sa ):
    m = 0.0000001
    for s in sa:
        if math.fabs(s) &gt; m:
            m = math.fabs(s)
    return m

def scale_sample( sa, scale ):
    ss = []
    for s in sa:
        ss.append(s*scale)
    return ss

def sum_samples( sa, sb ):
    ss = []
    ll = max(len(sa), len(sb))
    for idx in range(ll):
        if idx &lt; len(sa) and idx &lt; len(sb):
            ss.append(sa[idx]+sb[idx])
        elif idx &lt; len(sa):
            ss.append(sa[idx])
        elif idx &lt; len(sb):
            ss.append(sb[idx])
    return ss

def mix_sample( sa, sb, max_amp = global_max_amp):
    ua = unpack_sample(sa)
    ub = unpack_sample(sb)
    ss = sum_samples(ua,ub)
    mx = max_sample(ss)
    return pack_sample(scale_sample(ss,max_amp/mx))

def balance( sa, lpa, rpa, sb, lpb, rpb, max_amp = global_max_amp ):
    ua = unpack_sample(sa)
    ub = unpack_sample(sb)
    out_len = min(len(ua)-1,len(ub)-1)
    idx = 0
    while idx &lt; out_len:
        ua[idx] = ua[idx] * lpa
        ua[idx+1] = ua[idx+1] * rpa
        idx += 2
    idx = 0
    while idx &lt; out_len:
        ub[idx] = ub[idx] * lpa
        ub[idx+1] = ub[idx+1] * rpa
        idx += 2
    idx = 0
    ml = 0
    mr = 0
    while idx &lt; out_len:
        ua[idx] = ua[idx] + ub[idx]
        ua[idx+1] = ua[idx+1] + ub[idx+1]
        if math.fabs(ua[idx]) &gt; ml:
            ml = math.fabs(ua[idx])
        if math.fabs(ua[idx+1]) &gt; mr:
            mr = math.fabs(ua[idx+1])
        idx += 2
    idx = 0
    while idx &lt; out_len:
        ua[idx] = ua[idx] * max_amp/ml
        ua[idx+1] = ua[idx+1] * max_amp/mr
        idx += 2
    return pack_sample(ua)

def reverb( sa, delay = 0.05, sr = 44100.0, max_amp = global_max_amp ):
    delay_samples = int(sr*delay)

    ua = unpack_sample(sa)
    output = ua[:delay_samples]
    for idx in range(delay_samples,len(ua)):
        output.append(ua[idx]+ua[idx-delay_samples]*0.125+ua[idx-int(delay_samples*0.75)]*0.25+ua[idx-int(delay_samples*0.50)]*0.5+ua[idx-int(delay_samples*0.25)]*1.0)
    mx = max_sample(output)

    return pack_sample(scale_sample(output,max_amp/mx))

def gen_envelope( max_amp = global_max_amp, sr = 44100.0, t = 5.0 ):
    total_samples = int(sr*t)
    cur_amp = max_amp
    attack_slope = 0.0
    decay_slope = ((max_amp*0.75) - max_amp) / (total_samples/2.0 - total_samples/4.0)
    sustain_slope = 0.0
    release_slope = (0.0 - (max_amp*0.75)) / (total_samples - ((total_samples/4.0)*3.0))
    envelope = []
    for idx in range(total_samples):
        envelope.append(cur_amp)
        if idx &lt; total_samples/4.0:
            cur_amp += attack_slope
        elif idx &lt; total_samples/2.0:
            cur_amp += decay_slope
        elif idx &lt; (total_samples/4.0)*3.0:
            cur_amp += sustain_slope
        elif idx &lt; total_samples:
            cur_amp += release_slope
    return envelope

def smooth_decay( sample ):
    us = unpack_sample(sample)
    quarter = len(us)//4
    scale = slope = 1.0 / float(quarter)
    idx = -quarter
    while idx &lt; 0:
        us[idx] = us[idx] - us[idx]*scale
        scale = scale + slope
        idx += 1
    return pack_sample(us)

note_cache = {}
def gen_note( note = &#34;C4&#34;, sr = 44100.0, t = 5.0, max_amp = global_max_amp, dyn = &#34;f&#34;, voice = 0 ):

    freq = notes[note]
    total_samples = (sr*t)
    period = sr / freq
    natural_freq = 2.0*math.pi/period

    key = ( note, int(total_samples), max_amp, dyn, voice )
    if key in note_cache:
        if verbose:
            print(&#34;Using cached note&#34;,key)
        return note_cache[key]

    if max_amp &gt; 0.0:
        cs = get_cached_sample( note, dyn, voice, verbose )
        if cs:
            nc = int(total_samples)*4
            ls = len(cs)
            if nc &gt; ls:
                output_signal = cs + (wave.struct.pack(&#39;h&#39;,0) * ((nc-ls)//2))
            else:
                output_signal = smooth_decay(cs[:nc])
        else:
            envelope = gen_envelope( max_amp, sr, t )
            #evaluate x-axis / time-axis positions
            time_axis = [float(x)*natural_freq for x in range(int(period))]
            #evaluate singal amplitudes for the period
            period_amp_data = [math.sin(x) for x in time_axis]
            #repeat the singal, and pack as short, 16 bit values
            output_signal = b&#39;&#39;
            for i in range(int(total_samples/period)):
                for j in range(len(period_amp_data)):
                    output_signal += wave.struct.pack(&#39;h&#39;, int(period_amp_data[j]*envelope[i*j]))
    else:
        output_signal = wave.struct.pack(&#39;h&#39;,0)*int(total_samples)

    if verbose:
        print(&#34;Missed note cache&#34;,key)
    note_cache[key] = output_signal
    return output_signal

chord_cache = {}
def gen_chord( name = &#34;C4Maj&#34;, sr = 44100.0, t = 5.0, max_amp = global_max_amp, dyn = &#34;f&#34;,voice=0 ):
    key = ( name, int(sr*t), max_amp, dyn, voice )
    if key in chord_cache:
        if verbose:
            print(&#34;Using cached chord&#34;,key)
        return chord_cache[key]
    tones = chord(name)
    signal = b&#39;&#39;
    for tn in tones:
        if not signal:
            signal = gen_note(tn,sr,t,max_amp,dyn,voice)
        else:
            signal = mix_sample(signal,gen_note(tn,sr,t,max_amp,dyn,voice))

    if verbose:
        print(&#34;Missed chord cache&#34;,key)
    chord_cache[key] = signal
    return signal

def gen_line( line, tempo = 120, add_swing = False, dyn = &#34;f&#34;,voice=0 ):
    tt_time = 0.0
    output = b&#39;&#39;
    swing = 0.0
    dyns = [ &#34;ff&#34;,&#34;f&#34;,&#34;mf&#34;,&#34;f&#34;,&#34;ff&#34;]
    if add_swing:
        swing = (duration(tempo, 8)/8.0)
    dyn_idx = dyns.index(dyn)
    eidx = 0
    while eidx &lt; len(line):
        cur_dyn = dyns[dyn_idx]
        event = line[eidx]
        tn = duration(tempo, event.value)+swing
        if event.name == &#34;R&#34;:
            output += gen_note( note=&#34;C4&#34;, t=tn, max_amp = 0.0, voice = voice)
            eidx += 1
        else:
            nn = event.name
            is_chord = isinstance(event,C)
            while eidx+1 &lt; len(line) and line[eidx+1].name == &#34;R&#34;:
                tn += duration(tempo, line[eidx+1].value)+swing
                swing = -swing
                eidx += 1
            if is_chord:
                output += gen_chord( name=nn, t = tn, dyn=cur_dyn, voice = voice)
            else:
                output += gen_note( note=nn, t = tn, dyn=cur_dyn, voice = voice)
            eidx += 1

        tt_time += tn
        swing = -swing
        if random.randint(1,10) &lt;= 4:
            dyn_idx += 1
            if dyn_idx &gt;= len(dyns):
                dyn_idx = 0
    if verbose:
        print(&#34;gen_line, total_time&#34;,tt_time)
        print(&#34;calculated total_time&#34;,total_time(line,tempo))
    return output

def improvise_scale_phrase( chords, note_idx=8, note_dir=1, harm=False, transpose = 1, delta_gen = None, ending = False ):
    melody = []
    cidx = 0

    if delta_gen:
        note_dir = delta_gen.getDelta()
    elif random.randint(1,10) &lt;= 2:
        note_dir = -note_dir
    note_len = 0
    if random.randint(1,10) &lt;= 4:
        nl = bass_note_lengths
        nt = bass_times
    else:
        nl = note_lengths
        nt = times

    while cidx &lt; len(chords):
        root,octave,type = split_chord(chords[cidx].name)
        cname = join_chord(root,octave+transpose,type)

        scl_name = random.choice(chord2scales(cname))
        scl = scale(scl_name,transpose=-1,octaves=3)
        if note_idx &gt;= len(scl):
            note_idx = len(scl)-2
            note_dir = -1

        eighths = value_to_eighths[chords[cidx].value]

        while ( eighths &gt; 0 ):
            if (not note_len) or (note_len &gt; eighths):
                if ending:
                    note_len = random.randint(min(eighths,4),eighths)
                else:
                    note_len = random.randint(1,eighths)

            rest = ( random.randint(1,20) &lt;= 2) and not ending
            if rest:
                nn = N(&#39;R&#39;,nl[note_len])
            elif harm:
                chord = []
                chord_len = random.randint(2,3)
                cn_idx = note_idx
                while chord_len &gt;= 0 and cn_idx &gt;= 0:
                    chord.append(scl[cn_idx])
                    chord_len -= 1
                    cn_idx -= 2
                nn = C(chord,nl[note_len])
            else:
                nn = N(scl[note_idx],nl[note_len])
            melody.append(nn)
            eighths -= nt[note_len]
            note_idx += note_dir
            if note_idx &lt; 0:
                note_idx = 1
                note_dir = 1
            elif note_idx &gt;= len(scl):
                note_idx = len(scl)-2
                note_dir = -1

            if delta_gen:
                note_dir = delta_gen.getDelta()
            elif not eighths:
                note_dir = -note_dir
        cidx += 1
    return((melody,note_idx,note_dir))

def improvise_melody_phrase( chords, melody, transpose=1, harm = False ):
    cidx = 0
    midx = 0
    phrase = []
    total_eighths = 0
    chord_total_eighths = 0
    while midx &lt; len(melody):
        scl_name = random.choice(chord2scales(chords[cidx].name))
        scl = scale(scl_name,transpose=transpose,octaves=3)
        if melody[midx].name == &#39;R&#39;:
            phrase.append(melody[midx])
        elif harm:
            cn_idx = closest_index_in_scale( melody[midx].name, scl) + 12
            chord = []
            chord_len = random.randint(2,3)
            while chord_len &gt;= 0 and cn_idx &gt;= 0:
                chord.append(scl[cn_idx])
                chord_len -= 1
                cn_idx -= 2
            phrase.append(C(chord,melody[midx].value))
        elif random.randint(1,10) &lt; 4 and midx &lt; len(melody)-1 and melody[midx+1].name != &#39;R&#39;:
            cn_idx = closest_index_in_scale( melody[midx].name, scl)
            en_idx = closest_index_in_scale( melody[midx+1].name, scl)
            inc = 1
            if en_idx &lt; cn_idx:
                inc = -1
            eighths = value_to_eighths[melody[midx].value]
            while eighths:
                phrase.append(N(scl[cn_idx],8))
                eighths -= 1
                cn_idx += inc
                if cn_idx &lt; 0 or cn_idx &gt;= len(scl):
                    inc = -inc
                    cn_idx += inc
        else:
            phrase.append(melody[midx])

        total_eighths += value_to_eighths[melody[midx].value]
        while chord_total_eighths &lt; total_eighths:
            chord_total_eighths += value_to_eighths[chords[cidx].value]
            cidx += 1
        cidx = min(cidx,len(chords)-1)
        midx += 1
    return phrase

def improvise_ex( song, transpose = 1, delta_gen = None ):
    phrase_eighths = (value_to_eighths[song.beat] * song.measure) * phrase_measures
    cidx = 0
    midx = 0
    melody = []
    note_idx = 8
    note_dir = 1
    harm = False

    line_time = 0
    cidx = 0

    while cidx &lt; len(song.chords) and line_time &lt; song.song_time:
        chord_phrase = []
        chord_phrase_eighths = 0
        chord_phrase_time = 0
        while cidx &lt; len(song.chords) and chord_phrase_eighths &lt; phrase_eighths and line_time+chord_phrase_time &lt; song.song_time:
            chord_phrase.append(song.chords[cidx])
            chord_phrase_eighths += value_to_eighths[song.chords[cidx].value]
            chord_phrase_time = total_time(chord_phrase,song.tempo)
            cidx += 1
        melody_phrase = []
        melody_phrase_eighths = 0
        melody_phrase_time = 0
        if song.melody:
            while midx &lt; len(song.melody) and melody_phrase_eighths &lt; phrase_eighths and line_time+melody_phrase_time &lt; song.song_time:
                melody_phrase.append(song.melody[midx])
                melody_phrase_eighths += value_to_eighths[song.melody[midx].value]
                melody_phrase_time = total_time(melody_phrase)
                midx += 1

        phrase = []
        harm = (random.randint(1,10) &lt; 5)
        if melody_phrase and (random.randint(1,10) &lt; 5):
            phrase = improvise_melody_phrase( chord_phrase, melody_phrase,transpose, harm )
        elif chord_phrase:
            phrase,note_idx,note_dir = improvise_scale_phrase( chord_phrase, note_idx, note_dir, harm, transpose, delta_gen, ending = ( cidx &gt;= (len(song.chords)-8)) )

        melody += phrase
        line_time = total_time(melody,song.tempo)

    if verbose:
        print(&#34;improvise_ex:&#34;,melody)
    return melody

def arpegiate_ex( song, transpose = -1 ):
    phrase_eighths = value_to_eighths[song.beat] * song.measure * phrase_measures
    phrase_index = 0
    phrase = []
    eighths = phrase_eighths
    while ( eighths &gt; 0 ):
        note_len = min(eighths,random.choice([1,2,4]))
        phrase.append(note_len)
        eighths -= bass_times[note_len]

    line = []
    note_idx = 8
    note_dir = 1
    cidx = 0
    lay_out = False
    punch_chord = False
    play_chord = False
    phrase_time = 0
    line_time = 0
    cidx = 0

    while cidx &lt; len(song.chords) and line_time &lt; song.song_time:
        c = song.chords[cidx]
        cc = c.name
        root,octave,type = split_chord(cc)
        cp = join_chord(root,octave+transpose,type)
        eighths = value_to_eighths[c.value]

        if not phrase_time:
            play_chord = (random.randint(1,10) &lt;= 2)
            punch_chord = (random.randint(1,10) &lt;= 2)
            lay_out = (random.randint(1,10) &lt;= 2)

        phrase_time += eighths
        if phrase_time &gt;= phrase_eighths:
            phrase_time = 0

        cn = chord(cp)
        if (play_chord):
            line.append(c)
        elif (lay_out):
            line.append(N(&#34;R&#34;,c.value))
        elif (punch_chord):
            while ( eighths &gt; 0 ):
                if phrase_index &gt;= len(phrase):
                    phrase_index = 0

                note_len = phrase[phrase_index]
                if note_len &lt; 0:
                    note_len = -note_len
                    nn = &#34;R&#34;
                note_len = min(eighths, note_len)
                line.append(C(cc,bass_note_lengths[note_len]))
                cc = &#34;R&#34;
                eighths -= bass_times[note_len]
                phrase_index += 1
        else:
            idx = 0
            while ( eighths &gt; 0 ):
                if idx &gt;= len(cn):
                    idx = 0

                if phrase_index &gt;= len(phrase):
                    phrase_index = 0

                note_len = phrase[phrase_index]
                nn = cn[idx]
                if note_len &lt; 0:
                    note_len = -note_len
                    nn = &#34;R&#34;

                if lay_out:
                    nn = &#34;R&#34;

                note_len = min(eighths, note_len)
                if punch_chord and not lay_out:
                    line.append(C(cc,bass_note_lengths[note_len]))
                    cc = &#34;R&#34;
                else:
                    line.append(N(nn,bass_note_lengths[note_len]))
                eighths -= bass_times[note_len]
                idx += 1
                phrase_index += 1
        line_time = total_time(line,song.tempo)
        cidx += 1
    if verbose:
        print(&#34;arpegiate_ex:&#34;,line)
    return line

def play_song( s, out_file = &#34;soundgen.wav&#34; ):
    if verbose:
        print(&#34;Phrase measures&#34;,phrase_measures)

    if verbose:
        print(&#34;Synthesizing Melody&#34;)
        print(&#34;melody eighths =&#34;,sum_eighths(s.melody))
    melody_line = gen_line( s.melody,s.tempo,s.swing,&#34;f&#34;,s.melody_voice)
    if debug:
        save_sample(melody_line,&#34;melody.wav&#34;,1)
    melody_line = reverb(melody_line)
    if debug:
        save_sample(melody_line,&#34;melodyrv.wav&#34;,1)

    if verbose:
        print(&#34;Synthesizing Bass&#34;)
        print(&#34;bass eighths = &#34;,sum_eighths(s.rhythm))
    bass_line = gen_line( s.rhythm,s.tempo,s.swing,&#34;f&#34;,s.rhythm_voice)
    if debug:
        save_sample(bass_line,&#34;bass.wav&#34;,1)
    bass_line = reverb(bass_line)
    if debug:
        save_sample(bass_line,&#34;bassrv.wav&#34;,1)
    if verbose:
        print(&#34;Balancing Channels&#34;)
    output = balance( bass_line, 0.60, 0.40, melody_line, 0.40, 0.60 )
    if verbose:
        print(&#34;Saving song&#34;)
    save_sample(output,out_file,2)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="slides_sound.soundgen.arpegiate_ex"><code class="name flex">
<span>def <span class="ident">arpegiate_ex</span></span>(<span>song, transpose=-1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def arpegiate_ex( song, transpose = -1 ):
    phrase_eighths = value_to_eighths[song.beat] * song.measure * phrase_measures
    phrase_index = 0
    phrase = []
    eighths = phrase_eighths
    while ( eighths &gt; 0 ):
        note_len = min(eighths,random.choice([1,2,4]))
        phrase.append(note_len)
        eighths -= bass_times[note_len]

    line = []
    note_idx = 8
    note_dir = 1
    cidx = 0
    lay_out = False
    punch_chord = False
    play_chord = False
    phrase_time = 0
    line_time = 0
    cidx = 0

    while cidx &lt; len(song.chords) and line_time &lt; song.song_time:
        c = song.chords[cidx]
        cc = c.name
        root,octave,type = split_chord(cc)
        cp = join_chord(root,octave+transpose,type)
        eighths = value_to_eighths[c.value]

        if not phrase_time:
            play_chord = (random.randint(1,10) &lt;= 2)
            punch_chord = (random.randint(1,10) &lt;= 2)
            lay_out = (random.randint(1,10) &lt;= 2)

        phrase_time += eighths
        if phrase_time &gt;= phrase_eighths:
            phrase_time = 0

        cn = chord(cp)
        if (play_chord):
            line.append(c)
        elif (lay_out):
            line.append(N(&#34;R&#34;,c.value))
        elif (punch_chord):
            while ( eighths &gt; 0 ):
                if phrase_index &gt;= len(phrase):
                    phrase_index = 0

                note_len = phrase[phrase_index]
                if note_len &lt; 0:
                    note_len = -note_len
                    nn = &#34;R&#34;
                note_len = min(eighths, note_len)
                line.append(C(cc,bass_note_lengths[note_len]))
                cc = &#34;R&#34;
                eighths -= bass_times[note_len]
                phrase_index += 1
        else:
            idx = 0
            while ( eighths &gt; 0 ):
                if idx &gt;= len(cn):
                    idx = 0

                if phrase_index &gt;= len(phrase):
                    phrase_index = 0

                note_len = phrase[phrase_index]
                nn = cn[idx]
                if note_len &lt; 0:
                    note_len = -note_len
                    nn = &#34;R&#34;

                if lay_out:
                    nn = &#34;R&#34;

                note_len = min(eighths, note_len)
                if punch_chord and not lay_out:
                    line.append(C(cc,bass_note_lengths[note_len]))
                    cc = &#34;R&#34;
                else:
                    line.append(N(nn,bass_note_lengths[note_len]))
                eighths -= bass_times[note_len]
                idx += 1
                phrase_index += 1
        line_time = total_time(line,song.tempo)
        cidx += 1
    if verbose:
        print(&#34;arpegiate_ex:&#34;,line)
    return line</code></pre>
</details>
</dd>
<dt id="slides_sound.soundgen.balance"><code class="name flex">
<span>def <span class="ident">balance</span></span>(<span>sa, lpa, rpa, sb, lpb, rpb, max_amp=15386.0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def balance( sa, lpa, rpa, sb, lpb, rpb, max_amp = global_max_amp ):
    ua = unpack_sample(sa)
    ub = unpack_sample(sb)
    out_len = min(len(ua)-1,len(ub)-1)
    idx = 0
    while idx &lt; out_len:
        ua[idx] = ua[idx] * lpa
        ua[idx+1] = ua[idx+1] * rpa
        idx += 2
    idx = 0
    while idx &lt; out_len:
        ub[idx] = ub[idx] * lpa
        ub[idx+1] = ub[idx+1] * rpa
        idx += 2
    idx = 0
    ml = 0
    mr = 0
    while idx &lt; out_len:
        ua[idx] = ua[idx] + ub[idx]
        ua[idx+1] = ua[idx+1] + ub[idx+1]
        if math.fabs(ua[idx]) &gt; ml:
            ml = math.fabs(ua[idx])
        if math.fabs(ua[idx+1]) &gt; mr:
            mr = math.fabs(ua[idx+1])
        idx += 2
    idx = 0
    while idx &lt; out_len:
        ua[idx] = ua[idx] * max_amp/ml
        ua[idx+1] = ua[idx+1] * max_amp/mr
        idx += 2
    return pack_sample(ua)</code></pre>
</details>
</dd>
<dt id="slides_sound.soundgen.gen_chord"><code class="name flex">
<span>def <span class="ident">gen_chord</span></span>(<span>name='C4Maj', sr=44100.0, t=5.0, max_amp=15386.0, dyn='f', voice=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_chord( name = &#34;C4Maj&#34;, sr = 44100.0, t = 5.0, max_amp = global_max_amp, dyn = &#34;f&#34;,voice=0 ):
    key = ( name, int(sr*t), max_amp, dyn, voice )
    if key in chord_cache:
        if verbose:
            print(&#34;Using cached chord&#34;,key)
        return chord_cache[key]
    tones = chord(name)
    signal = b&#39;&#39;
    for tn in tones:
        if not signal:
            signal = gen_note(tn,sr,t,max_amp,dyn,voice)
        else:
            signal = mix_sample(signal,gen_note(tn,sr,t,max_amp,dyn,voice))

    if verbose:
        print(&#34;Missed chord cache&#34;,key)
    chord_cache[key] = signal
    return signal</code></pre>
</details>
</dd>
<dt id="slides_sound.soundgen.gen_envelope"><code class="name flex">
<span>def <span class="ident">gen_envelope</span></span>(<span>max_amp=15386.0, sr=44100.0, t=5.0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_envelope( max_amp = global_max_amp, sr = 44100.0, t = 5.0 ):
    total_samples = int(sr*t)
    cur_amp = max_amp
    attack_slope = 0.0
    decay_slope = ((max_amp*0.75) - max_amp) / (total_samples/2.0 - total_samples/4.0)
    sustain_slope = 0.0
    release_slope = (0.0 - (max_amp*0.75)) / (total_samples - ((total_samples/4.0)*3.0))
    envelope = []
    for idx in range(total_samples):
        envelope.append(cur_amp)
        if idx &lt; total_samples/4.0:
            cur_amp += attack_slope
        elif idx &lt; total_samples/2.0:
            cur_amp += decay_slope
        elif idx &lt; (total_samples/4.0)*3.0:
            cur_amp += sustain_slope
        elif idx &lt; total_samples:
            cur_amp += release_slope
    return envelope</code></pre>
</details>
</dd>
<dt id="slides_sound.soundgen.gen_line"><code class="name flex">
<span>def <span class="ident">gen_line</span></span>(<span>line, tempo=120, add_swing=False, dyn='f', voice=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_line( line, tempo = 120, add_swing = False, dyn = &#34;f&#34;,voice=0 ):
    tt_time = 0.0
    output = b&#39;&#39;
    swing = 0.0
    dyns = [ &#34;ff&#34;,&#34;f&#34;,&#34;mf&#34;,&#34;f&#34;,&#34;ff&#34;]
    if add_swing:
        swing = (duration(tempo, 8)/8.0)
    dyn_idx = dyns.index(dyn)
    eidx = 0
    while eidx &lt; len(line):
        cur_dyn = dyns[dyn_idx]
        event = line[eidx]
        tn = duration(tempo, event.value)+swing
        if event.name == &#34;R&#34;:
            output += gen_note( note=&#34;C4&#34;, t=tn, max_amp = 0.0, voice = voice)
            eidx += 1
        else:
            nn = event.name
            is_chord = isinstance(event,C)
            while eidx+1 &lt; len(line) and line[eidx+1].name == &#34;R&#34;:
                tn += duration(tempo, line[eidx+1].value)+swing
                swing = -swing
                eidx += 1
            if is_chord:
                output += gen_chord( name=nn, t = tn, dyn=cur_dyn, voice = voice)
            else:
                output += gen_note( note=nn, t = tn, dyn=cur_dyn, voice = voice)
            eidx += 1

        tt_time += tn
        swing = -swing
        if random.randint(1,10) &lt;= 4:
            dyn_idx += 1
            if dyn_idx &gt;= len(dyns):
                dyn_idx = 0
    if verbose:
        print(&#34;gen_line, total_time&#34;,tt_time)
        print(&#34;calculated total_time&#34;,total_time(line,tempo))
    return output</code></pre>
</details>
</dd>
<dt id="slides_sound.soundgen.gen_note"><code class="name flex">
<span>def <span class="ident">gen_note</span></span>(<span>note='C4', sr=44100.0, t=5.0, max_amp=15386.0, dyn='f', voice=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_note( note = &#34;C4&#34;, sr = 44100.0, t = 5.0, max_amp = global_max_amp, dyn = &#34;f&#34;, voice = 0 ):

    freq = notes[note]
    total_samples = (sr*t)
    period = sr / freq
    natural_freq = 2.0*math.pi/period

    key = ( note, int(total_samples), max_amp, dyn, voice )
    if key in note_cache:
        if verbose:
            print(&#34;Using cached note&#34;,key)
        return note_cache[key]

    if max_amp &gt; 0.0:
        cs = get_cached_sample( note, dyn, voice, verbose )
        if cs:
            nc = int(total_samples)*4
            ls = len(cs)
            if nc &gt; ls:
                output_signal = cs + (wave.struct.pack(&#39;h&#39;,0) * ((nc-ls)//2))
            else:
                output_signal = smooth_decay(cs[:nc])
        else:
            envelope = gen_envelope( max_amp, sr, t )
            #evaluate x-axis / time-axis positions
            time_axis = [float(x)*natural_freq for x in range(int(period))]
            #evaluate singal amplitudes for the period
            period_amp_data = [math.sin(x) for x in time_axis]
            #repeat the singal, and pack as short, 16 bit values
            output_signal = b&#39;&#39;
            for i in range(int(total_samples/period)):
                for j in range(len(period_amp_data)):
                    output_signal += wave.struct.pack(&#39;h&#39;, int(period_amp_data[j]*envelope[i*j]))
    else:
        output_signal = wave.struct.pack(&#39;h&#39;,0)*int(total_samples)

    if verbose:
        print(&#34;Missed note cache&#34;,key)
    note_cache[key] = output_signal
    return output_signal</code></pre>
</details>
</dd>
<dt id="slides_sound.soundgen.improvise_ex"><code class="name flex">
<span>def <span class="ident">improvise_ex</span></span>(<span>song, transpose=1, delta_gen=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def improvise_ex( song, transpose = 1, delta_gen = None ):
    phrase_eighths = (value_to_eighths[song.beat] * song.measure) * phrase_measures
    cidx = 0
    midx = 0
    melody = []
    note_idx = 8
    note_dir = 1
    harm = False

    line_time = 0
    cidx = 0

    while cidx &lt; len(song.chords) and line_time &lt; song.song_time:
        chord_phrase = []
        chord_phrase_eighths = 0
        chord_phrase_time = 0
        while cidx &lt; len(song.chords) and chord_phrase_eighths &lt; phrase_eighths and line_time+chord_phrase_time &lt; song.song_time:
            chord_phrase.append(song.chords[cidx])
            chord_phrase_eighths += value_to_eighths[song.chords[cidx].value]
            chord_phrase_time = total_time(chord_phrase,song.tempo)
            cidx += 1
        melody_phrase = []
        melody_phrase_eighths = 0
        melody_phrase_time = 0
        if song.melody:
            while midx &lt; len(song.melody) and melody_phrase_eighths &lt; phrase_eighths and line_time+melody_phrase_time &lt; song.song_time:
                melody_phrase.append(song.melody[midx])
                melody_phrase_eighths += value_to_eighths[song.melody[midx].value]
                melody_phrase_time = total_time(melody_phrase)
                midx += 1

        phrase = []
        harm = (random.randint(1,10) &lt; 5)
        if melody_phrase and (random.randint(1,10) &lt; 5):
            phrase = improvise_melody_phrase( chord_phrase, melody_phrase,transpose, harm )
        elif chord_phrase:
            phrase,note_idx,note_dir = improvise_scale_phrase( chord_phrase, note_idx, note_dir, harm, transpose, delta_gen, ending = ( cidx &gt;= (len(song.chords)-8)) )

        melody += phrase
        line_time = total_time(melody,song.tempo)

    if verbose:
        print(&#34;improvise_ex:&#34;,melody)
    return melody</code></pre>
</details>
</dd>
<dt id="slides_sound.soundgen.improvise_melody_phrase"><code class="name flex">
<span>def <span class="ident">improvise_melody_phrase</span></span>(<span>chords, melody, transpose=1, harm=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def improvise_melody_phrase( chords, melody, transpose=1, harm = False ):
    cidx = 0
    midx = 0
    phrase = []
    total_eighths = 0
    chord_total_eighths = 0
    while midx &lt; len(melody):
        scl_name = random.choice(chord2scales(chords[cidx].name))
        scl = scale(scl_name,transpose=transpose,octaves=3)
        if melody[midx].name == &#39;R&#39;:
            phrase.append(melody[midx])
        elif harm:
            cn_idx = closest_index_in_scale( melody[midx].name, scl) + 12
            chord = []
            chord_len = random.randint(2,3)
            while chord_len &gt;= 0 and cn_idx &gt;= 0:
                chord.append(scl[cn_idx])
                chord_len -= 1
                cn_idx -= 2
            phrase.append(C(chord,melody[midx].value))
        elif random.randint(1,10) &lt; 4 and midx &lt; len(melody)-1 and melody[midx+1].name != &#39;R&#39;:
            cn_idx = closest_index_in_scale( melody[midx].name, scl)
            en_idx = closest_index_in_scale( melody[midx+1].name, scl)
            inc = 1
            if en_idx &lt; cn_idx:
                inc = -1
            eighths = value_to_eighths[melody[midx].value]
            while eighths:
                phrase.append(N(scl[cn_idx],8))
                eighths -= 1
                cn_idx += inc
                if cn_idx &lt; 0 or cn_idx &gt;= len(scl):
                    inc = -inc
                    cn_idx += inc
        else:
            phrase.append(melody[midx])

        total_eighths += value_to_eighths[melody[midx].value]
        while chord_total_eighths &lt; total_eighths:
            chord_total_eighths += value_to_eighths[chords[cidx].value]
            cidx += 1
        cidx = min(cidx,len(chords)-1)
        midx += 1
    return phrase</code></pre>
</details>
</dd>
<dt id="slides_sound.soundgen.improvise_scale_phrase"><code class="name flex">
<span>def <span class="ident">improvise_scale_phrase</span></span>(<span>chords, note_idx=8, note_dir=1, harm=False, transpose=1, delta_gen=None, ending=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def improvise_scale_phrase( chords, note_idx=8, note_dir=1, harm=False, transpose = 1, delta_gen = None, ending = False ):
    melody = []
    cidx = 0

    if delta_gen:
        note_dir = delta_gen.getDelta()
    elif random.randint(1,10) &lt;= 2:
        note_dir = -note_dir
    note_len = 0
    if random.randint(1,10) &lt;= 4:
        nl = bass_note_lengths
        nt = bass_times
    else:
        nl = note_lengths
        nt = times

    while cidx &lt; len(chords):
        root,octave,type = split_chord(chords[cidx].name)
        cname = join_chord(root,octave+transpose,type)

        scl_name = random.choice(chord2scales(cname))
        scl = scale(scl_name,transpose=-1,octaves=3)
        if note_idx &gt;= len(scl):
            note_idx = len(scl)-2
            note_dir = -1

        eighths = value_to_eighths[chords[cidx].value]

        while ( eighths &gt; 0 ):
            if (not note_len) or (note_len &gt; eighths):
                if ending:
                    note_len = random.randint(min(eighths,4),eighths)
                else:
                    note_len = random.randint(1,eighths)

            rest = ( random.randint(1,20) &lt;= 2) and not ending
            if rest:
                nn = N(&#39;R&#39;,nl[note_len])
            elif harm:
                chord = []
                chord_len = random.randint(2,3)
                cn_idx = note_idx
                while chord_len &gt;= 0 and cn_idx &gt;= 0:
                    chord.append(scl[cn_idx])
                    chord_len -= 1
                    cn_idx -= 2
                nn = C(chord,nl[note_len])
            else:
                nn = N(scl[note_idx],nl[note_len])
            melody.append(nn)
            eighths -= nt[note_len]
            note_idx += note_dir
            if note_idx &lt; 0:
                note_idx = 1
                note_dir = 1
            elif note_idx &gt;= len(scl):
                note_idx = len(scl)-2
                note_dir = -1

            if delta_gen:
                note_dir = delta_gen.getDelta()
            elif not eighths:
                note_dir = -note_dir
        cidx += 1
    return((melody,note_idx,note_dir))</code></pre>
</details>
</dd>
<dt id="slides_sound.soundgen.load_music"><code class="name flex">
<span>def <span class="ident">load_music</span></span>(<span>music_file)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_music( music_file ):
    s = open(music_file,&#34;r&#34;).read()
    return eval(s)</code></pre>
</details>
</dd>
<dt id="slides_sound.soundgen.max_sample"><code class="name flex">
<span>def <span class="ident">max_sample</span></span>(<span>sa)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def max_sample( sa ):
    m = 0.0000001
    for s in sa:
        if math.fabs(s) &gt; m:
            m = math.fabs(s)
    return m</code></pre>
</details>
</dd>
<dt id="slides_sound.soundgen.mix_sample"><code class="name flex">
<span>def <span class="ident">mix_sample</span></span>(<span>sa, sb, max_amp=15386.0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mix_sample( sa, sb, max_amp = global_max_amp):
    ua = unpack_sample(sa)
    ub = unpack_sample(sb)
    ss = sum_samples(ua,ub)
    mx = max_sample(ss)
    return pack_sample(scale_sample(ss,max_amp/mx))</code></pre>
</details>
</dd>
<dt id="slides_sound.soundgen.pack_channels"><code class="name flex">
<span>def <span class="ident">pack_channels</span></span>(<span>left, right)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pack_channels( left, right ):
    idx = 0
    both = []
    while idx &lt; len(left):
        both.append(left[idx])
        both.append(right[idx])
        idx += 1
    return pack_sample(both)</code></pre>
</details>
</dd>
<dt id="slides_sound.soundgen.pack_sample"><code class="name flex">
<span>def <span class="ident">pack_sample</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pack_sample( s ):
    sample = bytearray(len(s)*2)
    wave.struct.pack_into(&#39;%dh&#39;%len(s),sample,0,*[int(sv) for sv in s])
    return sample</code></pre>
</details>
</dd>
<dt id="slides_sound.soundgen.play_song"><code class="name flex">
<span>def <span class="ident">play_song</span></span>(<span>s, out_file='soundgen.wav')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def play_song( s, out_file = &#34;soundgen.wav&#34; ):
    if verbose:
        print(&#34;Phrase measures&#34;,phrase_measures)

    if verbose:
        print(&#34;Synthesizing Melody&#34;)
        print(&#34;melody eighths =&#34;,sum_eighths(s.melody))
    melody_line = gen_line( s.melody,s.tempo,s.swing,&#34;f&#34;,s.melody_voice)
    if debug:
        save_sample(melody_line,&#34;melody.wav&#34;,1)
    melody_line = reverb(melody_line)
    if debug:
        save_sample(melody_line,&#34;melodyrv.wav&#34;,1)

    if verbose:
        print(&#34;Synthesizing Bass&#34;)
        print(&#34;bass eighths = &#34;,sum_eighths(s.rhythm))
    bass_line = gen_line( s.rhythm,s.tempo,s.swing,&#34;f&#34;,s.rhythm_voice)
    if debug:
        save_sample(bass_line,&#34;bass.wav&#34;,1)
    bass_line = reverb(bass_line)
    if debug:
        save_sample(bass_line,&#34;bassrv.wav&#34;,1)
    if verbose:
        print(&#34;Balancing Channels&#34;)
    output = balance( bass_line, 0.60, 0.40, melody_line, 0.40, 0.60 )
    if verbose:
        print(&#34;Saving song&#34;)
    save_sample(output,out_file,2)</code></pre>
</details>
</dd>
<dt id="slides_sound.soundgen.reverb"><code class="name flex">
<span>def <span class="ident">reverb</span></span>(<span>sa, delay=0.05, sr=44100.0, max_amp=15386.0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reverb( sa, delay = 0.05, sr = 44100.0, max_amp = global_max_amp ):
    delay_samples = int(sr*delay)

    ua = unpack_sample(sa)
    output = ua[:delay_samples]
    for idx in range(delay_samples,len(ua)):
        output.append(ua[idx]+ua[idx-delay_samples]*0.125+ua[idx-int(delay_samples*0.75)]*0.25+ua[idx-int(delay_samples*0.50)]*0.5+ua[idx-int(delay_samples*0.25)]*1.0)
    mx = max_sample(output)

    return pack_sample(scale_sample(output,max_amp/mx))</code></pre>
</details>
</dd>
<dt id="slides_sound.soundgen.save_sample"><code class="name flex">
<span>def <span class="ident">save_sample</span></span>(<span>output, fname, channels)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_sample ( output, fname, channels ):
    out_file = wave.open(fname,&#34;w&#34;)
    out_file.setparams((channels,2,44100,len(output)//2,&#34;NONE&#34;,&#34;noncompressed&#34;))
    out_file.writeframes(output)
    out_file.close()</code></pre>
</details>
</dd>
<dt id="slides_sound.soundgen.scale_sample"><code class="name flex">
<span>def <span class="ident">scale_sample</span></span>(<span>sa, scale)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scale_sample( sa, scale ):
    ss = []
    for s in sa:
        ss.append(s*scale)
    return ss</code></pre>
</details>
</dd>
<dt id="slides_sound.soundgen.set_debug"><code class="name flex">
<span>def <span class="ident">set_debug</span></span>(<span>db)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_debug( db ):
    global debug
    debug = db</code></pre>
</details>
</dd>
<dt id="slides_sound.soundgen.set_verbose"><code class="name flex">
<span>def <span class="ident">set_verbose</span></span>(<span>vb)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_verbose( vb ):
    global verbose
    verbose = vb</code></pre>
</details>
</dd>
<dt id="slides_sound.soundgen.smooth_decay"><code class="name flex">
<span>def <span class="ident">smooth_decay</span></span>(<span>sample)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def smooth_decay( sample ):
    us = unpack_sample(sample)
    quarter = len(us)//4
    scale = slope = 1.0 / float(quarter)
    idx = -quarter
    while idx &lt; 0:
        us[idx] = us[idx] - us[idx]*scale
        scale = scale + slope
        idx += 1
    return pack_sample(us)</code></pre>
</details>
</dd>
<dt id="slides_sound.soundgen.sum_eighths"><code class="name flex">
<span>def <span class="ident">sum_eighths</span></span>(<span>line)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sum_eighths( line ):
    eighths = 0
    for s in line:
        eighths += value_to_eighths[s.value]
    return eighths</code></pre>
</details>
</dd>
<dt id="slides_sound.soundgen.sum_samples"><code class="name flex">
<span>def <span class="ident">sum_samples</span></span>(<span>sa, sb)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sum_samples( sa, sb ):
    ss = []
    ll = max(len(sa), len(sb))
    for idx in range(ll):
        if idx &lt; len(sa) and idx &lt; len(sb):
            ss.append(sa[idx]+sb[idx])
        elif idx &lt; len(sa):
            ss.append(sa[idx])
        elif idx &lt; len(sb):
            ss.append(sb[idx])
    return ss</code></pre>
</details>
</dd>
<dt id="slides_sound.soundgen.unpack_channels"><code class="name flex">
<span>def <span class="ident">unpack_channels</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unpack_channels( s ):
    up = unpack_sample(s)
    left = []
    right = []
    idx = 0
    while idx &lt; len(up)-1:
        left.append(up[idx])
        right.append(up[idx+1])
        idx += 2
    return left,right</code></pre>
</details>
</dd>
<dt id="slides_sound.soundgen.unpack_sample"><code class="name flex">
<span>def <span class="ident">unpack_sample</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unpack_sample( s ):
    sl = len(s)//2
    up = wave.struct.unpack_from(&#39;%dh&#39;%sl,s,0)
    us = [float(sv) for sv in up]
    return us</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="slides_sound.soundgen.DeltaGenerator"><code class="flex name class">
<span>class <span class="ident">DeltaGenerator</span></span>
<span>(</span><span>deltas=[])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DeltaGenerator:
    def __init__(self, deltas = [] ):
        self.deltas = deltas
        self.didx = 0

    def getDelta( self ):
        delta = 0
        if self.deltas:
            delta = self.deltas[self.didx]
            self.didx = self.didx + 1
            if self.didx &gt;= len(self.deltas):
                self.didx = 0
        return delta</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="slides_sound.soundgen.DeltaGenerator.getDelta"><code class="name flex">
<span>def <span class="ident">getDelta</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getDelta( self ):
    delta = 0
    if self.deltas:
        delta = self.deltas[self.didx]
        self.didx = self.didx + 1
        if self.didx &gt;= len(self.deltas):
            self.didx = 0
    return delta</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="slides_sound.soundgen.arpegiate_ex" href="#slides_sound.soundgen.arpegiate_ex">arpegiate_ex</a></code></li>
<li><code><a title="slides_sound.soundgen.balance" href="#slides_sound.soundgen.balance">balance</a></code></li>
<li><code><a title="slides_sound.soundgen.gen_chord" href="#slides_sound.soundgen.gen_chord">gen_chord</a></code></li>
<li><code><a title="slides_sound.soundgen.gen_envelope" href="#slides_sound.soundgen.gen_envelope">gen_envelope</a></code></li>
<li><code><a title="slides_sound.soundgen.gen_line" href="#slides_sound.soundgen.gen_line">gen_line</a></code></li>
<li><code><a title="slides_sound.soundgen.gen_note" href="#slides_sound.soundgen.gen_note">gen_note</a></code></li>
<li><code><a title="slides_sound.soundgen.improvise_ex" href="#slides_sound.soundgen.improvise_ex">improvise_ex</a></code></li>
<li><code><a title="slides_sound.soundgen.improvise_melody_phrase" href="#slides_sound.soundgen.improvise_melody_phrase">improvise_melody_phrase</a></code></li>
<li><code><a title="slides_sound.soundgen.improvise_scale_phrase" href="#slides_sound.soundgen.improvise_scale_phrase">improvise_scale_phrase</a></code></li>
<li><code><a title="slides_sound.soundgen.load_music" href="#slides_sound.soundgen.load_music">load_music</a></code></li>
<li><code><a title="slides_sound.soundgen.max_sample" href="#slides_sound.soundgen.max_sample">max_sample</a></code></li>
<li><code><a title="slides_sound.soundgen.mix_sample" href="#slides_sound.soundgen.mix_sample">mix_sample</a></code></li>
<li><code><a title="slides_sound.soundgen.pack_channels" href="#slides_sound.soundgen.pack_channels">pack_channels</a></code></li>
<li><code><a title="slides_sound.soundgen.pack_sample" href="#slides_sound.soundgen.pack_sample">pack_sample</a></code></li>
<li><code><a title="slides_sound.soundgen.play_song" href="#slides_sound.soundgen.play_song">play_song</a></code></li>
<li><code><a title="slides_sound.soundgen.reverb" href="#slides_sound.soundgen.reverb">reverb</a></code></li>
<li><code><a title="slides_sound.soundgen.save_sample" href="#slides_sound.soundgen.save_sample">save_sample</a></code></li>
<li><code><a title="slides_sound.soundgen.scale_sample" href="#slides_sound.soundgen.scale_sample">scale_sample</a></code></li>
<li><code><a title="slides_sound.soundgen.set_debug" href="#slides_sound.soundgen.set_debug">set_debug</a></code></li>
<li><code><a title="slides_sound.soundgen.set_verbose" href="#slides_sound.soundgen.set_verbose">set_verbose</a></code></li>
<li><code><a title="slides_sound.soundgen.smooth_decay" href="#slides_sound.soundgen.smooth_decay">smooth_decay</a></code></li>
<li><code><a title="slides_sound.soundgen.sum_eighths" href="#slides_sound.soundgen.sum_eighths">sum_eighths</a></code></li>
<li><code><a title="slides_sound.soundgen.sum_samples" href="#slides_sound.soundgen.sum_samples">sum_samples</a></code></li>
<li><code><a title="slides_sound.soundgen.unpack_channels" href="#slides_sound.soundgen.unpack_channels">unpack_channels</a></code></li>
<li><code><a title="slides_sound.soundgen.unpack_sample" href="#slides_sound.soundgen.unpack_sample">unpack_sample</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="slides_sound.soundgen.DeltaGenerator" href="#slides_sound.soundgen.DeltaGenerator">DeltaGenerator</a></code></h4>
<ul class="">
<li><code><a title="slides_sound.soundgen.DeltaGenerator.getDelta" href="#slides_sound.soundgen.DeltaGenerator.getDelta">getDelta</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>