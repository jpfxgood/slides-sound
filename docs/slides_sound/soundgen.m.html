<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>slides_sound.soundgen API documentation</title>
    <meta name="description" content="" />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">
    <li class="set"><h3><a href="#header-variables">Module variables</a></h3>
      
  <ul>
    <li class="mono"><a href="#slides_sound.soundgen.bass_note_lengths">bass_note_lengths</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.bass_times">bass_times</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.chord_cache">chord_cache</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.debug">debug</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.eighths_to_value">eighths_to_value</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.global_max_amp">global_max_amp</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.note_cache">note_cache</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.note_lengths">note_lengths</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.notes">notes</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.phrase_measures">phrase_measures</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.tempo">tempo</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.times">times</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.value_to_eighths">value_to_eighths</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.verbose">verbose</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#slides_sound.soundgen.arpegiate">arpegiate</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.arpegiate_ex">arpegiate_ex</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.balance">balance</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.gen_chord">gen_chord</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.gen_envelope">gen_envelope</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.gen_line">gen_line</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.gen_note">gen_note</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.improvise">improvise</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.improvise_ex">improvise_ex</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.improvise_melody_phrase">improvise_melody_phrase</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.improvise_scale_phrase">improvise_scale_phrase</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.load_music">load_music</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.max_sample">max_sample</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.mix_sample">mix_sample</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.pack_sample">pack_sample</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.play_song">play_song</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.punch_chords">punch_chords</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.reverb">reverb</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.save_sample">save_sample</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.scale_sample">scale_sample</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.set_debug">set_debug</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.set_verbose">set_verbose</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.smooth_decay">smooth_decay</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.sum_eighths">sum_eighths</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.sum_samples">sum_samples</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.unpack_sample">unpack_sample</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#slides_sound.soundgen.DeltaGenerator">DeltaGenerator</a></span>
        
          
  <ul>
    <li class="mono"><a href="#slides_sound.soundgen.DeltaGenerator.__init__">__init__</a></li>
    <li class="mono"><a href="#slides_sound.soundgen.DeltaGenerator.getDelta">getDelta</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">slides_sound.soundgen</span> module</h1>
  
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-slides_sound.soundgen', this);">Show source &equiv;</a></p>
  <div id="source-slides_sound.soundgen" class="source">
    <pre><code>#!/usr/bin/python -u
import math
import wave
from .notes import notes, scale, chord, C, N, S, Song, duration, chord2scales, split_chord, join_chord, init_sample_cache, get_cached_sample, closest_index_in_scale
import time
import re
import random
import sys

# Tempo in bpm
tempo = 120
global_max_amp = 15386.00
phrase_measures = random.choice([2,4,8])
verbose = False
debug = False
random.seed()

def set_verbose( vb ):
    global verbose
    verbose = vb

def set_debug( db ):
    global debug
    debug = db

def unpack_sample( s ):
    sl = len(s)//2
    up = wave.struct.unpack_from('%dh'%sl,s,0)
    us = [float(sv) for sv in up]
    return us

def pack_sample( s ):
    sample = bytearray(len(s)*2)
    wave.struct.pack_into('%dh'%len(s),sample,0,*[int(sv) for sv in s])
    return sample

def max_sample( sa ):
    m = 0.0000001
    for s in sa:
        if math.fabs(s) > m:
            m = math.fabs(s)
    return m

def scale_sample( sa, scale ):
    ss = []
    for s in sa:
        ss.append(s*scale)
    return ss

def sum_samples( sa, sb ):
    ss = []
    ll = max(len(sa), len(sb))
    for idx in range(ll):
        if idx < len(sa) and idx < len(sb):
            ss.append(sa[idx]+sb[idx])
        elif idx < len(sa):
            ss.append(sa[idx])
        elif idx < len(sb):
            ss.append(sb[idx])
    return ss

def mix_sample( sa, sb, max_amp = global_max_amp):
    ua = unpack_sample(sa)
    ub = unpack_sample(sb)
    ss = sum_samples(ua,ub)
    mx = max_sample(ss)
    return pack_sample(scale_sample(ss,max_amp/mx))

def balance( sa, lpa, rpa, sb, lpb, rpb, max_amp = global_max_amp ):
    ua = unpack_sample(sa)
    ub = unpack_sample(sb)
    sal = scale_sample(ua, lpa)
    sar = scale_sample(ua, rpa)
    sbl = scale_sample(ub, lpb)
    sbr = scale_sample(ub, rpb)
    ls = sum_samples(sal,sbl)
    rs = sum_samples(sar,sbr)
    ml = max_sample(ls)
    mr = max_sample(rs)
    return ( pack_sample(scale_sample(ls,max_amp/ml)), pack_sample(scale_sample(rs,max_amp/mr)) )

def reverb( sa, delay = 0.05, sr = 44100.0, max_amp = global_max_amp ):
    delay_samples = int(sr*delay)

    ua = unpack_sample(sa)
    output = ua[:delay_samples]
    for idx in range(delay_samples,len(ua)):
        output.append(ua[idx]+ua[idx-delay_samples]*0.125+ua[idx-int(delay_samples*0.75)]*0.25+ua[idx-int(delay_samples*0.50)]*0.5+ua[idx-int(delay_samples*0.25)]*1.0)
    mx = max_sample(output)

    return pack_sample(scale_sample(output,max_amp/mx))

def gen_envelope( max_amp = global_max_amp, sr = 44100.0, t = 5.0 ):
    total_samples = int(sr*t)
    cur_amp = max_amp
    attack_slope = 0.0
    decay_slope = ((max_amp*0.75) - max_amp) / (total_samples/2.0 - total_samples/4.0)
    sustain_slope = 0.0
    release_slope = (0.0 - (max_amp*0.75)) / (total_samples - ((total_samples/4.0)*3.0))
    envelope = []
    for idx in range(total_samples):
        envelope.append(cur_amp)
        if idx < total_samples/4.0:
            cur_amp += attack_slope
        elif idx < total_samples/2.0:
            cur_amp += decay_slope
        elif idx < (total_samples/4.0)*3.0:
            cur_amp += sustain_slope
        elif idx < total_samples:
            cur_amp += release_slope
    return envelope

def smooth_decay( sample ):
    us = unpack_sample(sample)
    quarter = len(us)//4
    scale = slope = 1.0 / float(quarter)
    idx = -quarter
    while idx < 0:
        us[idx] = us[idx] - us[idx]*scale
        scale = scale + slope
        idx += 1
    return pack_sample(us)

note_cache = {}
def gen_note( note = "C4", sr = 44100.0, t = 5.0, max_amp = global_max_amp, dyn = "f", voice = 0 ):

    freq = notes[note]
    total_samples = sr*t
    period = sr / freq
    natural_freq = 2.0*math.pi/period

    key = ( note, int(total_samples), max_amp, dyn, voice )
    if key in note_cache:
        if verbose:
            print("Using cached note",key)
        return note_cache[key]

    if max_amp > 0.0:
        cs = get_cached_sample( note, dyn, voice, verbose )
        if cs:
            nc = int(total_samples)*2
            ls = len(cs)
            if nc > ls:
                output_signal = cs + (wave.struct.pack('h',0) * ((nc-ls)//2))
            else:
                output_signal = smooth_decay(cs[:int(total_samples)*2])
        else:
            envelope = gen_envelope( max_amp, sr, t )
            #evaluate x-axis / time-axis positions
            time_axis = [float(x)*natural_freq for x in range(int(period))]
            #evaluate singal amplitudes for the period
            period_amp_data = [math.sin(x) for x in time_axis]
            #repeat the singal, and pack as short, 16 bit values
            output_signal = b''
            for i in range(int(total_samples/period)):
                for j in range(len(period_amp_data)):
                    output_signal += wave.struct.pack('h', int(period_amp_data[j]*envelope[i*j]))
    else:
        output_signal = wave.struct.pack('h',0)*int(total_samples)

    if verbose:
        print("Missed note cache",key)
    note_cache[key] = output_signal
    return output_signal

chord_cache = {}
def gen_chord( name = "C4Maj", sr = 44100.0, t = 5.0, max_amp = global_max_amp, dyn = "f",voice=0 ):
    key = ( name, int(sr*t), max_amp, dyn, voice )
    if key in chord_cache:
        if verbose:
            print("Using cached chord",key)
        return chord_cache[key]
    tones = chord(name)
    signal = ''
    for tn in tones:
        if not signal:
            signal = gen_note(tn,sr,t,max_amp,dyn,voice)
        else:
            signal = mix_sample(signal,gen_note(tn,sr,t,max_amp,dyn,voice))

    if verbose:
        print("Missed chord cache",key)
    chord_cache[key] = signal
    return signal

def gen_line( line, tempo = 120, add_swing = False, dyn = "f",voice=0 ):
    total_time = 0.0
    output = b''
    swing = 0.0
    dyns = [ "ff","f","mf","f","ff"]
    if add_swing:
        swing = (duration(tempo, 8)/8.0)
    dyn_idx = dyns.index(dyn)
    eidx = 0
    while eidx < len(line):
        cur_dyn = dyns[dyn_idx]
        event = line[eidx]
        tn = duration(tempo, event.value)+swing
        if event.name == "R":
            output += gen_note( note="C4", t=tn, max_amp = 0.0, voice = voice)
            eidx += 1
        else:
            nn = event.name
            is_chord = isinstance(event,C)
            while eidx+1 < len(line) and line[eidx+1].name == "R":
                tn += duration(tempo, line[eidx+1].value)+swing
                swing = -swing
                eidx += 1
            if is_chord:
                output += gen_chord( name=nn, t = tn, dyn=cur_dyn, voice = voice)
            else:
                output += gen_note( note=nn, t = tn, dyn=cur_dyn, voice = voice)
            eidx += 1

        total_time += tn
        swing = -swing
        if random.randint(1,10) <= 4:
            dyn_idx += 1
            if dyn_idx >= len(dyns):
                dyn_idx = 0
    if verbose:
        print("gen_line, total_time",total_time)
    return output


value_to_eighths = {
    1.5:12,
    1:8,
    2.5:6,
    2:4,
    4.5:3,
    4:2,
    8:1
    }

eighths_to_value = {
    12:1.5,
    8:1,
    6:2.5,
    4:2,
    3:4.5,
    2:4,
    1:8
    }

note_lengths = [0,8,8,8,4,4,4,2,1]
times = [0,1,1,1,2,2,2,4,8]
bass_note_lengths = [0,8,4,4,4,2,2,2,1]
bass_times = [0,1,2,2,2,4,4,4,8]

def sum_eighths( line ):
    eighths = 0
    for s in line:
        eighths += value_to_eighths[s.value]
    return eighths

def improvise( chords, transpose = 1 ):
    phrase_cache = {}
    melody = []
    note_idx = 8
    note_dir = 1
    for c in chords:
        root,octave,type = split_chord(c.name)
        cname = join_chord(root,octave+transpose,type)
        if ((cname,c.value) in phrase_cache) and (random.randint(1,2) == 2):
            melody += phrase_cache[(cname,c.value)]
            continue

        scl_name = random.choice(chord2scales(cname))
        scl = scale(scl_name,transpose=-1,octaves=3)
        eighths = value_to_eighths[c.value]
        if note_idx >= len(scl):
            note_idx = len(scl)-2
            note_dir = -1
        if random.randint(1,10) <= 2:
            note_dir = -note_dir
        phrase = []
        note_len = 0
        harm = (random.randint(1,10) <= 4)
        while ( eighths > 0 ):
            if (not note_len) or (note_len > eighths):
                note_len = random.randint(1,eighths)

            rest = ( random.randint(1,10) <= 2)
            if rest:
                nn = N('R',note_lengths[note_len])
            elif harm:
                chord = []
                chord_len = random.randint(2,3)
                cn_idx = note_idx
                while chord_len >= 0 and cn_idx >= 0:
                    chord.append(scl[cn_idx])
                    chord_len -= 1
                    cn_idx -= 2
                nn = C(chord,note_lengths[note_len])
            else:
                nn = N(scl[note_idx],note_lengths[note_len])
            melody.append(nn)
            phrase.append(nn)
            eighths -= times[note_len]
            note_idx += note_dir
            if note_idx < 0:
                note_idx = 1
                note_dir = 1
            elif note_idx >= len(scl):
                note_idx = len(scl)-2
                note_dir = -1
            if not eighths:
                note_dir = -note_dir
        phrase_cache[(cname,c.value)] = phrase
    return(melody)

def improvise_scale_phrase( chords, note_idx=8, note_dir=1, harm=False, transpose = 1, delta_gen = None, ending = False ):
    melody = []
    cidx = 0

    if delta_gen:
        note_dir = delta_gen.getDelta()
    elif random.randint(1,10) <= 2:
        note_dir = -note_dir
    note_len = 0
    if random.randint(1,10) <= 4:
        nl = bass_note_lengths
        nt = bass_times
    else:
        nl = note_lengths
        nt = times

    while cidx < len(chords):
        root,octave,type = split_chord(chords[cidx].name)
        cname = join_chord(root,octave+transpose,type)

        scl_name = random.choice(chord2scales(cname))
        scl = scale(scl_name,transpose=-1,octaves=3)
        if note_idx >= len(scl):
            note_idx = len(scl)-2
            note_dir = -1

        eighths = value_to_eighths[chords[cidx].value]

        while ( eighths > 0 ):
            if (not note_len) or (note_len > eighths):
                if ending:
                    note_len = random.randint(min(eighths,4),eighths)
                else:
                    note_len = random.randint(1,eighths)

            rest = ( random.randint(1,20) <= 2) and not ending
            if rest:
                nn = N('R',nl[note_len])
            elif harm:
                chord = []
                chord_len = random.randint(2,3)
                cn_idx = note_idx
                while chord_len >= 0 and cn_idx >= 0:
                    chord.append(scl[cn_idx])
                    chord_len -= 1
                    cn_idx -= 2
                nn = C(chord,nl[note_len])
            else:
                nn = N(scl[note_idx],nl[note_len])
            melody.append(nn)
            eighths -= nt[note_len]
            note_idx += note_dir
            if note_idx < 0:
                note_idx = 1
                note_dir = 1
            elif note_idx >= len(scl):
                note_idx = len(scl)-2
                note_dir = -1

            if delta_gen:
                note_dir = delta_gen.getDelta()
            elif not eighths:
                note_dir = -note_dir
        cidx += 1
    return((melody,note_idx,note_dir))

def improvise_melody_phrase( chords, melody, harm = False ):
    cidx = 0
    midx = 0
    phrase = []
    total_eighths = 0
    chord_total_eighths = 0
    while midx < len(melody):
        scl_name = random.choice(chord2scales(chords[cidx].name))
        scl = scale(scl_name,transpose=0,octaves=3)
        if melody[midx].name == 'R':
            phrase.append(melody[midx])
        elif harm:
            cn_idx = closest_index_in_scale( melody[midx].name, scl) + 12
            chord = []
            chord_len = random.randint(2,3)
            while chord_len >= 0 and cn_idx >= 0:
                chord.append(scl[cn_idx])
                chord_len -= 1
                cn_idx -= 2
            phrase.append(C(chord,melody[midx].value))
        elif random.randint(1,10) < 4 and midx < len(melody)-1 and melody[midx+1].name != 'R':
            cn_idx = closest_index_in_scale( melody[midx].name, scl)
            en_idx = closest_index_in_scale( melody[midx+1].name, scl)
            inc = 1
            if en_idx < cn_idx:
                inc = -1
            eighths = value_to_eighths[melody[midx].value]
            while eighths:
                phrase.append(N(scl[cn_idx],8))
                eighths -= 1
                cn_idx += inc
                if cn_idx < 0 or cn_idx >= len(scl):
                    inc = -inc
                    cn_idx += inc
        else:
            phrase.append(melody[midx])

        total_eighths += value_to_eighths[melody[midx].value]
        while chord_total_eighths < total_eighths:
            chord_total_eighths += value_to_eighths[chords[cidx].value]
            cidx += 1
        cidx = min(cidx,len(chords)-1)
        midx += 1
    return phrase

def improvise_ex( song, transpose = 1, delta_gen = None ):
    total_eighths = 0
    phrase_eighths = (value_to_eighths[song.beat] * song.measure) * phrase_measures
    cidx = 0
    midx = 0
    melody = []
    note_idx = 8
    note_dir = 1
    harm = False

    song_eighths = 0
    while cidx < len(song.chords):
        song_eighths += value_to_eighths[song.chords[cidx].value]
        cidx += 1
    cidx = 0

    while cidx < len(song.chords):
        chord_phrase = []
        chord_phrase_eighths = 0
        while cidx < len(song.chords) and chord_phrase_eighths < phrase_eighths:
            chord_phrase.append(song.chords[cidx])
            chord_phrase_eighths += value_to_eighths[song.chords[cidx].value]
            cidx += 1
        melody_phrase = []
        melody_phrase_eighths = 0
        if song.melody:
            while midx < len(song.melody) and melody_phrase_eighths < phrase_eighths:
                melody_phrase.append(song.melody[midx])
                melody_phrase_eighths += value_to_eighths[song.melody[midx].value]
                midx += 1

        harm = (random.randint(1,10) < 5)
        if melody_phrase and (random.randint(1,10) < 5 or total_eighths < phrase_eighths or total_eighths >= song_eighths-phrase_eighths):
            phrase = improvise_melody_phrase( chord_phrase, melody_phrase, harm )
        else:
            phrase,note_idx,note_dir = improvise_scale_phrase( chord_phrase, note_idx, note_dir, harm, transpose, delta_gen, ending = ( cidx >= (len(song.chords)-8)) )

        melody += phrase
        total_eighths += chord_phrase_eighths

    if verbose:
        print("improvise_ex:",melody)
    return melody

def arpegiate( chords, transpose = -1 ):
    line = []
    phrase_cache = {}
    for c in chords:
        if ((c.name,c.value) in phrase_cache) and (random.randint(1,2) == 2):
            line += phrase_cache[(c.name,c.value)]
            continue
        root,octave,type = split_chord(c.name)
        cp = join_chord(root,octave+transpose,type)
        eighths = value_to_eighths[c.value]
        cn = chord(cp)
        idx = 0
        phrase = []
        while ( eighths > 0 ):
            if idx >= len(cn):
                idx = 0
            note_len = random.randint(1,eighths)
            nn = cn[idx]
            if idx and random.randint(1,10) <= 2:
                nn = "R"
            line.append(N(nn,bass_note_lengths[note_len]))
            phrase.append(N(nn,bass_note_lengths[note_len]))
            eighths -= bass_times[note_len]
            idx += 1
        phrase_cache[(c.name,c.value)] = phrase
    return line

def arpegiate_ex( song, transpose = -1 ):
    phrase_eighths = value_to_eighths[song.beat] * song.measure * phrase_measures
    phrase_index = 0
    phrase = []
    eighths = phrase_eighths
    while ( eighths > 0 ):
        note_len = min(eighths,random.choice([1,2,4]))
        phrase.append(note_len)
        eighths -= bass_times[note_len]

    line = []
    note_idx = 8
    note_dir = 1
    cidx = 0
    lay_out = False
    punch_chord = False
    play_chord = False
    phrase_time = 0
    while cidx < len(song.chords):
        c = song.chords[cidx]
        cc = c.name
        root,octave,type = split_chord(cc)
        cp = join_chord(root,octave+transpose,type)
        eighths = value_to_eighths[c.value]

        if not phrase_time:
            play_chord = (random.randint(1,10) <= 2)
            punch_chord = (random.randint(1,10) <= 2)
            lay_out = (random.randint(1,10) <= 2)

        phrase_time += eighths
        if phrase_time >= phrase_eighths:
            phrase_time = 0

        cn = chord(cp)
        if (play_chord):
            line.append(c)
        elif (lay_out):
            line.append(N("R",c.value))
        elif (punch_chord):
            while ( eighths > 0 ):
                if phrase_index >= len(phrase):
                    phrase_index = 0

                note_len = phrase[phrase_index]
                if note_len < 0:
                    note_len = -note_len
                    nn = "R"
                note_len = min(eighths, note_len)
                line.append(C(cc,bass_note_lengths[note_len]))
                cc = "R"
                eighths -= bass_times[note_len]
                phrase_index += 1
        else:
            idx = 0
            while ( eighths > 0 ):
                if idx >= len(cn):
                    idx = 0

                if phrase_index >= len(phrase):
                    phrase_index = 0

                note_len = phrase[phrase_index]
                nn = cn[idx]
                if note_len < 0:
                    note_len = -note_len
                    nn = "R"

                if lay_out:
                    nn = "R"

                note_len = min(eighths, note_len)
                if punch_chord and not lay_out:
                    line.append(C(cc,bass_note_lengths[note_len]))
                    cc = "R"
                else:
                    line.append(N(nn,bass_note_lengths[note_len]))
                eighths -= bass_times[note_len]
                idx += 1
                phrase_index += 1

        cidx += 1
    if verbose:
        print("arpegiate_ex:",line)
    return line

def punch_chords( song, transpose = 0 ):
    phrase_eighths = value_to_eighths[song.beat] * song.measure * 4
    phrase_index = 0
    phrase = []
    for idx in range(0,3):
        eighths = phrase_eighths // 4
        while ( eighths > 0 ):
            note_len = min(eighths,random.choice([1,2,4]))
            if eighths < (phrase_eighths // 4) and (random.randint(1,10) <= 8):
                phrase.append(-note_len)
            else:
                phrase.append(note_len)
            eighths -= bass_times[note_len]
    if verbose:
        print("punch_chords:",phrase)
    line = []
    note_idx = 8
    note_dir = 1
    cidx = 0
    while cidx < len(song.chords):
        c = song.chords[cidx]
        root,octave,type = split_chord(c.name)
        cp = join_chord(root,octave+transpose,type)
        eighths = value_to_eighths[c.value]
        lay_out = False
        while ( eighths > 0 ):
            if phrase_index >= len(phrase):
                phrase_index = 0

            if phrase_index == 0:
                lay_out = ( random.randint(1,10) < 4 )
                if lay_out:
                    if verbose:
                        print("chords laying out")
                else:
                    if verbose:
                        print("chords playing")

            note_len = phrase[phrase_index]
            nn = cp
            if note_len < 0:
                note_len = -note_len
                nn = "R"

            if lay_out:
                nn = "R"
            note_len = min(eighths, note_len)
            line.append(C(nn,bass_note_lengths[note_len]))
            eighths -= bass_times[note_len]
            phrase_index += 1
        cidx += 1
    if verbose:
        print("punch_chords:",line)
    return line

def save_sample ( output, fname, channels ):
    out_file = wave.open(fname,"w")
    out_file.setparams((channels,2,44100,len(output)//2,"NONE","noncompressed"))
    out_file.writeframes(output)
    out_file.close()

def play_song( s, out_file = "soundgen.wav" ):
    if verbose:
        print("Phrase measures",phrase_measures)
#    print "Synthesizing Chords"
#    chords = punch_chords(s)
#    chords = s.chords
#    print "chord eighths =",sum_eighths(chords)
#    chord_progression = gen_line( chords ,s.tempo, s.swing, "ff" )
#    save_sample(chord_progression,"chords.wav",1)
    if verbose:
        print("Synthesizing Melody")
        print("melody eighths =",sum_eighths(s.melody))
    melody_line = gen_line( s.melody,s.tempo,s.swing,"f",s.melody_voice)
    if debug:
        save_sample(melody_line,"melody.wav",1)
    melody_line = reverb(melody_line)
    if debug:
        save_sample(melody_line,"melodyrv.wav",1)

    if verbose:
        print("Synthesizing Bass")
        print("bass eighths = ",sum_eighths(s.rhythm))
    bass_line = gen_line( s.rhythm,s.tempo,s.swing,"f",s.rhythm_voice)
    if debug:
        save_sample(bass_line,"bass.wav",1)
    bass_line = reverb(bass_line)
    if debug:
        save_sample(bass_line,"bassrv.wav",1)

#    print "Mixing Chords and Bass"
#    chords_n_bass = mix_sample(chord_progression, bass_line)
#    save_sample(chords_n_bass,"chordsnbass.wav",1)
    if verbose:
        print("Balancing Channels")
    ls,rs = balance( bass_line, 0.60, 0.40, melody_line, 0.40, 0.60 )
    if verbose:
        print("Saving song")
    idx = 0
    out_len = min(len(ls),len(rs))
    output = bytearray(out_len*4)
    while idx < out_len:
        wave.struct.pack_into("BBBB",output,idx*4,ls[idx],ls[idx+1],rs[idx],rs[idx+1])
        idx += 2
    save_sample(output,out_file,2)

class DeltaGenerator:
    def __init__(self, deltas = [] ):
        self.deltas = deltas
        self.didx = 0

    def getDelta( self ):
        delta = 0
        if self.deltas:
            delta = self.deltas[self.didx]
            self.didx = self.didx + 1
            if self.didx >= len(self.deltas):
                self.didx = 0
        return delta

def load_music( music_file ):
    s = open(music_file,"r").read()
    return eval(s)
</code></pre>
  </div>

  </header>

  <section id="section-items">
    <h2 class="section-title" id="header-variables">Module variables</h2>
      <div class="item">
      <p id="slides_sound.soundgen.bass_note_lengths" class="name">var <span class="ident">bass_note_lengths</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="slides_sound.soundgen.bass_times" class="name">var <span class="ident">bass_times</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="slides_sound.soundgen.chord_cache" class="name">var <span class="ident">chord_cache</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="slides_sound.soundgen.debug" class="name">var <span class="ident">debug</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="slides_sound.soundgen.eighths_to_value" class="name">var <span class="ident">eighths_to_value</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="slides_sound.soundgen.global_max_amp" class="name">var <span class="ident">global_max_amp</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="slides_sound.soundgen.note_cache" class="name">var <span class="ident">note_cache</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="slides_sound.soundgen.note_lengths" class="name">var <span class="ident">note_lengths</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="slides_sound.soundgen.notes" class="name">var <span class="ident">notes</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="slides_sound.soundgen.phrase_measures" class="name">var <span class="ident">phrase_measures</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="slides_sound.soundgen.tempo" class="name">var <span class="ident">tempo</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="slides_sound.soundgen.times" class="name">var <span class="ident">times</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="slides_sound.soundgen.value_to_eighths" class="name">var <span class="ident">value_to_eighths</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="slides_sound.soundgen.verbose" class="name">var <span class="ident">verbose</span></p>
      
  
  <div class="source_cont">
</div>

      </div>

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="slides_sound.soundgen.arpegiate">
    <p>def <span class="ident">arpegiate</span>(</p><p>chords, transpose=-1)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-slides_sound.soundgen.arpegiate', this);">Show source &equiv;</a></p>
  <div id="source-slides_sound.soundgen.arpegiate" class="source">
    <pre><code>def arpegiate( chords, transpose = -1 ):
    line = []
    phrase_cache = {}
    for c in chords:
        if ((c.name,c.value) in phrase_cache) and (random.randint(1,2) == 2):
            line += phrase_cache[(c.name,c.value)]
            continue
        root,octave,type = split_chord(c.name)
        cp = join_chord(root,octave+transpose,type)
        eighths = value_to_eighths[c.value]
        cn = chord(cp)
        idx = 0
        phrase = []
        while ( eighths > 0 ):
            if idx >= len(cn):
                idx = 0
            note_len = random.randint(1,eighths)
            nn = cn[idx]
            if idx and random.randint(1,10) <= 2:
                nn = "R"
            line.append(N(nn,bass_note_lengths[note_len]))
            phrase.append(N(nn,bass_note_lengths[note_len]))
            eighths -= bass_times[note_len]
            idx += 1
        phrase_cache[(c.name,c.value)] = phrase
    return line
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="slides_sound.soundgen.arpegiate_ex">
    <p>def <span class="ident">arpegiate_ex</span>(</p><p>song, transpose=-1)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-slides_sound.soundgen.arpegiate_ex', this);">Show source &equiv;</a></p>
  <div id="source-slides_sound.soundgen.arpegiate_ex" class="source">
    <pre><code>def arpegiate_ex( song, transpose = -1 ):
    phrase_eighths = value_to_eighths[song.beat] * song.measure * phrase_measures
    phrase_index = 0
    phrase = []
    eighths = phrase_eighths
    while ( eighths > 0 ):
        note_len = min(eighths,random.choice([1,2,4]))
        phrase.append(note_len)
        eighths -= bass_times[note_len]

    line = []
    note_idx = 8
    note_dir = 1
    cidx = 0
    lay_out = False
    punch_chord = False
    play_chord = False
    phrase_time = 0
    while cidx < len(song.chords):
        c = song.chords[cidx]
        cc = c.name
        root,octave,type = split_chord(cc)
        cp = join_chord(root,octave+transpose,type)
        eighths = value_to_eighths[c.value]

        if not phrase_time:
            play_chord = (random.randint(1,10) <= 2)
            punch_chord = (random.randint(1,10) <= 2)
            lay_out = (random.randint(1,10) <= 2)

        phrase_time += eighths
        if phrase_time >= phrase_eighths:
            phrase_time = 0

        cn = chord(cp)
        if (play_chord):
            line.append(c)
        elif (lay_out):
            line.append(N("R",c.value))
        elif (punch_chord):
            while ( eighths > 0 ):
                if phrase_index >= len(phrase):
                    phrase_index = 0

                note_len = phrase[phrase_index]
                if note_len < 0:
                    note_len = -note_len
                    nn = "R"
                note_len = min(eighths, note_len)
                line.append(C(cc,bass_note_lengths[note_len]))
                cc = "R"
                eighths -= bass_times[note_len]
                phrase_index += 1
        else:
            idx = 0
            while ( eighths > 0 ):
                if idx >= len(cn):
                    idx = 0

                if phrase_index >= len(phrase):
                    phrase_index = 0

                note_len = phrase[phrase_index]
                nn = cn[idx]
                if note_len < 0:
                    note_len = -note_len
                    nn = "R"

                if lay_out:
                    nn = "R"

                note_len = min(eighths, note_len)
                if punch_chord and not lay_out:
                    line.append(C(cc,bass_note_lengths[note_len]))
                    cc = "R"
                else:
                    line.append(N(nn,bass_note_lengths[note_len]))
                eighths -= bass_times[note_len]
                idx += 1
                phrase_index += 1

        cidx += 1
    if verbose:
        print("arpegiate_ex:",line)
    return line
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="slides_sound.soundgen.balance">
    <p>def <span class="ident">balance</span>(</p><p>sa, lpa, rpa, sb, lpb, rpb, max_amp=15386.0)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-slides_sound.soundgen.balance', this);">Show source &equiv;</a></p>
  <div id="source-slides_sound.soundgen.balance" class="source">
    <pre><code>def balance( sa, lpa, rpa, sb, lpb, rpb, max_amp = global_max_amp ):
    ua = unpack_sample(sa)
    ub = unpack_sample(sb)
    sal = scale_sample(ua, lpa)
    sar = scale_sample(ua, rpa)
    sbl = scale_sample(ub, lpb)
    sbr = scale_sample(ub, rpb)
    ls = sum_samples(sal,sbl)
    rs = sum_samples(sar,sbr)
    ml = max_sample(ls)
    mr = max_sample(rs)
    return ( pack_sample(scale_sample(ls,max_amp/ml)), pack_sample(scale_sample(rs,max_amp/mr)) )
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="slides_sound.soundgen.gen_chord">
    <p>def <span class="ident">gen_chord</span>(</p><p>name=&#39;C4Maj&#39;, sr=44100.0, t=5.0, max_amp=15386.0, dyn=&#39;f&#39;, voice=0)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-slides_sound.soundgen.gen_chord', this);">Show source &equiv;</a></p>
  <div id="source-slides_sound.soundgen.gen_chord" class="source">
    <pre><code>def gen_chord( name = "C4Maj", sr = 44100.0, t = 5.0, max_amp = global_max_amp, dyn = "f",voice=0 ):
    key = ( name, int(sr*t), max_amp, dyn, voice )
    if key in chord_cache:
        if verbose:
            print("Using cached chord",key)
        return chord_cache[key]
    tones = chord(name)
    signal = ''
    for tn in tones:
        if not signal:
            signal = gen_note(tn,sr,t,max_amp,dyn,voice)
        else:
            signal = mix_sample(signal,gen_note(tn,sr,t,max_amp,dyn,voice))

    if verbose:
        print("Missed chord cache",key)
    chord_cache[key] = signal
    return signal
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="slides_sound.soundgen.gen_envelope">
    <p>def <span class="ident">gen_envelope</span>(</p><p>max_amp=15386.0, sr=44100.0, t=5.0)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-slides_sound.soundgen.gen_envelope', this);">Show source &equiv;</a></p>
  <div id="source-slides_sound.soundgen.gen_envelope" class="source">
    <pre><code>def gen_envelope( max_amp = global_max_amp, sr = 44100.0, t = 5.0 ):
    total_samples = int(sr*t)
    cur_amp = max_amp
    attack_slope = 0.0
    decay_slope = ((max_amp*0.75) - max_amp) / (total_samples/2.0 - total_samples/4.0)
    sustain_slope = 0.0
    release_slope = (0.0 - (max_amp*0.75)) / (total_samples - ((total_samples/4.0)*3.0))
    envelope = []
    for idx in range(total_samples):
        envelope.append(cur_amp)
        if idx < total_samples/4.0:
            cur_amp += attack_slope
        elif idx < total_samples/2.0:
            cur_amp += decay_slope
        elif idx < (total_samples/4.0)*3.0:
            cur_amp += sustain_slope
        elif idx < total_samples:
            cur_amp += release_slope
    return envelope
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="slides_sound.soundgen.gen_line">
    <p>def <span class="ident">gen_line</span>(</p><p>line, tempo=120, add_swing=False, dyn=&#39;f&#39;, voice=0)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-slides_sound.soundgen.gen_line', this);">Show source &equiv;</a></p>
  <div id="source-slides_sound.soundgen.gen_line" class="source">
    <pre><code>def gen_line( line, tempo = 120, add_swing = False, dyn = "f",voice=0 ):
    total_time = 0.0
    output = b''
    swing = 0.0
    dyns = [ "ff","f","mf","f","ff"]
    if add_swing:
        swing = (duration(tempo, 8)/8.0)
    dyn_idx = dyns.index(dyn)
    eidx = 0
    while eidx < len(line):
        cur_dyn = dyns[dyn_idx]
        event = line[eidx]
        tn = duration(tempo, event.value)+swing
        if event.name == "R":
            output += gen_note( note="C4", t=tn, max_amp = 0.0, voice = voice)
            eidx += 1
        else:
            nn = event.name
            is_chord = isinstance(event,C)
            while eidx+1 < len(line) and line[eidx+1].name == "R":
                tn += duration(tempo, line[eidx+1].value)+swing
                swing = -swing
                eidx += 1
            if is_chord:
                output += gen_chord( name=nn, t = tn, dyn=cur_dyn, voice = voice)
            else:
                output += gen_note( note=nn, t = tn, dyn=cur_dyn, voice = voice)
            eidx += 1

        total_time += tn
        swing = -swing
        if random.randint(1,10) <= 4:
            dyn_idx += 1
            if dyn_idx >= len(dyns):
                dyn_idx = 0
    if verbose:
        print("gen_line, total_time",total_time)
    return output
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="slides_sound.soundgen.gen_note">
    <p>def <span class="ident">gen_note</span>(</p><p>note=&#39;C4&#39;, sr=44100.0, t=5.0, max_amp=15386.0, dyn=&#39;f&#39;, voice=0)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-slides_sound.soundgen.gen_note', this);">Show source &equiv;</a></p>
  <div id="source-slides_sound.soundgen.gen_note" class="source">
    <pre><code>def gen_note( note = "C4", sr = 44100.0, t = 5.0, max_amp = global_max_amp, dyn = "f", voice = 0 ):

    freq = notes[note]
    total_samples = sr*t
    period = sr / freq
    natural_freq = 2.0*math.pi/period

    key = ( note, int(total_samples), max_amp, dyn, voice )
    if key in note_cache:
        if verbose:
            print("Using cached note",key)
        return note_cache[key]

    if max_amp > 0.0:
        cs = get_cached_sample( note, dyn, voice, verbose )
        if cs:
            nc = int(total_samples)*2
            ls = len(cs)
            if nc > ls:
                output_signal = cs + (wave.struct.pack('h',0) * ((nc-ls)//2))
            else:
                output_signal = smooth_decay(cs[:int(total_samples)*2])
        else:
            envelope = gen_envelope( max_amp, sr, t )
            #evaluate x-axis / time-axis positions
            time_axis = [float(x)*natural_freq for x in range(int(period))]
            #evaluate singal amplitudes for the period
            period_amp_data = [math.sin(x) for x in time_axis]
            #repeat the singal, and pack as short, 16 bit values
            output_signal = b''
            for i in range(int(total_samples/period)):
                for j in range(len(period_amp_data)):
                    output_signal += wave.struct.pack('h', int(period_amp_data[j]*envelope[i*j]))
    else:
        output_signal = wave.struct.pack('h',0)*int(total_samples)

    if verbose:
        print("Missed note cache",key)
    note_cache[key] = output_signal
    return output_signal
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="slides_sound.soundgen.improvise">
    <p>def <span class="ident">improvise</span>(</p><p>chords, transpose=1)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-slides_sound.soundgen.improvise', this);">Show source &equiv;</a></p>
  <div id="source-slides_sound.soundgen.improvise" class="source">
    <pre><code>def improvise( chords, transpose = 1 ):
    phrase_cache = {}
    melody = []
    note_idx = 8
    note_dir = 1
    for c in chords:
        root,octave,type = split_chord(c.name)
        cname = join_chord(root,octave+transpose,type)
        if ((cname,c.value) in phrase_cache) and (random.randint(1,2) == 2):
            melody += phrase_cache[(cname,c.value)]
            continue

        scl_name = random.choice(chord2scales(cname))
        scl = scale(scl_name,transpose=-1,octaves=3)
        eighths = value_to_eighths[c.value]
        if note_idx >= len(scl):
            note_idx = len(scl)-2
            note_dir = -1
        if random.randint(1,10) <= 2:
            note_dir = -note_dir
        phrase = []
        note_len = 0
        harm = (random.randint(1,10) <= 4)
        while ( eighths > 0 ):
            if (not note_len) or (note_len > eighths):
                note_len = random.randint(1,eighths)

            rest = ( random.randint(1,10) <= 2)
            if rest:
                nn = N('R',note_lengths[note_len])
            elif harm:
                chord = []
                chord_len = random.randint(2,3)
                cn_idx = note_idx
                while chord_len >= 0 and cn_idx >= 0:
                    chord.append(scl[cn_idx])
                    chord_len -= 1
                    cn_idx -= 2
                nn = C(chord,note_lengths[note_len])
            else:
                nn = N(scl[note_idx],note_lengths[note_len])
            melody.append(nn)
            phrase.append(nn)
            eighths -= times[note_len]
            note_idx += note_dir
            if note_idx < 0:
                note_idx = 1
                note_dir = 1
            elif note_idx >= len(scl):
                note_idx = len(scl)-2
                note_dir = -1
            if not eighths:
                note_dir = -note_dir
        phrase_cache[(cname,c.value)] = phrase
    return(melody)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="slides_sound.soundgen.improvise_ex">
    <p>def <span class="ident">improvise_ex</span>(</p><p>song, transpose=1, delta_gen=None)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-slides_sound.soundgen.improvise_ex', this);">Show source &equiv;</a></p>
  <div id="source-slides_sound.soundgen.improvise_ex" class="source">
    <pre><code>def improvise_ex( song, transpose = 1, delta_gen = None ):
    total_eighths = 0
    phrase_eighths = (value_to_eighths[song.beat] * song.measure) * phrase_measures
    cidx = 0
    midx = 0
    melody = []
    note_idx = 8
    note_dir = 1
    harm = False

    song_eighths = 0
    while cidx < len(song.chords):
        song_eighths += value_to_eighths[song.chords[cidx].value]
        cidx += 1
    cidx = 0

    while cidx < len(song.chords):
        chord_phrase = []
        chord_phrase_eighths = 0
        while cidx < len(song.chords) and chord_phrase_eighths < phrase_eighths:
            chord_phrase.append(song.chords[cidx])
            chord_phrase_eighths += value_to_eighths[song.chords[cidx].value]
            cidx += 1
        melody_phrase = []
        melody_phrase_eighths = 0
        if song.melody:
            while midx < len(song.melody) and melody_phrase_eighths < phrase_eighths:
                melody_phrase.append(song.melody[midx])
                melody_phrase_eighths += value_to_eighths[song.melody[midx].value]
                midx += 1

        harm = (random.randint(1,10) < 5)
        if melody_phrase and (random.randint(1,10) < 5 or total_eighths < phrase_eighths or total_eighths >= song_eighths-phrase_eighths):
            phrase = improvise_melody_phrase( chord_phrase, melody_phrase, harm )
        else:
            phrase,note_idx,note_dir = improvise_scale_phrase( chord_phrase, note_idx, note_dir, harm, transpose, delta_gen, ending = ( cidx >= (len(song.chords)-8)) )

        melody += phrase
        total_eighths += chord_phrase_eighths

    if verbose:
        print("improvise_ex:",melody)
    return melody
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="slides_sound.soundgen.improvise_melody_phrase">
    <p>def <span class="ident">improvise_melody_phrase</span>(</p><p>chords, melody, harm=False)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-slides_sound.soundgen.improvise_melody_phrase', this);">Show source &equiv;</a></p>
  <div id="source-slides_sound.soundgen.improvise_melody_phrase" class="source">
    <pre><code>def improvise_melody_phrase( chords, melody, harm = False ):
    cidx = 0
    midx = 0
    phrase = []
    total_eighths = 0
    chord_total_eighths = 0
    while midx < len(melody):
        scl_name = random.choice(chord2scales(chords[cidx].name))
        scl = scale(scl_name,transpose=0,octaves=3)
        if melody[midx].name == 'R':
            phrase.append(melody[midx])
        elif harm:
            cn_idx = closest_index_in_scale( melody[midx].name, scl) + 12
            chord = []
            chord_len = random.randint(2,3)
            while chord_len >= 0 and cn_idx >= 0:
                chord.append(scl[cn_idx])
                chord_len -= 1
                cn_idx -= 2
            phrase.append(C(chord,melody[midx].value))
        elif random.randint(1,10) < 4 and midx < len(melody)-1 and melody[midx+1].name != 'R':
            cn_idx = closest_index_in_scale( melody[midx].name, scl)
            en_idx = closest_index_in_scale( melody[midx+1].name, scl)
            inc = 1
            if en_idx < cn_idx:
                inc = -1
            eighths = value_to_eighths[melody[midx].value]
            while eighths:
                phrase.append(N(scl[cn_idx],8))
                eighths -= 1
                cn_idx += inc
                if cn_idx < 0 or cn_idx >= len(scl):
                    inc = -inc
                    cn_idx += inc
        else:
            phrase.append(melody[midx])

        total_eighths += value_to_eighths[melody[midx].value]
        while chord_total_eighths < total_eighths:
            chord_total_eighths += value_to_eighths[chords[cidx].value]
            cidx += 1
        cidx = min(cidx,len(chords)-1)
        midx += 1
    return phrase
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="slides_sound.soundgen.improvise_scale_phrase">
    <p>def <span class="ident">improvise_scale_phrase</span>(</p><p>chords, note_idx=8, note_dir=1, harm=False, transpose=1, delta_gen=None, ending=False)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-slides_sound.soundgen.improvise_scale_phrase', this);">Show source &equiv;</a></p>
  <div id="source-slides_sound.soundgen.improvise_scale_phrase" class="source">
    <pre><code>def improvise_scale_phrase( chords, note_idx=8, note_dir=1, harm=False, transpose = 1, delta_gen = None, ending = False ):
    melody = []
    cidx = 0

    if delta_gen:
        note_dir = delta_gen.getDelta()
    elif random.randint(1,10) <= 2:
        note_dir = -note_dir
    note_len = 0
    if random.randint(1,10) <= 4:
        nl = bass_note_lengths
        nt = bass_times
    else:
        nl = note_lengths
        nt = times

    while cidx < len(chords):
        root,octave,type = split_chord(chords[cidx].name)
        cname = join_chord(root,octave+transpose,type)

        scl_name = random.choice(chord2scales(cname))
        scl = scale(scl_name,transpose=-1,octaves=3)
        if note_idx >= len(scl):
            note_idx = len(scl)-2
            note_dir = -1

        eighths = value_to_eighths[chords[cidx].value]

        while ( eighths > 0 ):
            if (not note_len) or (note_len > eighths):
                if ending:
                    note_len = random.randint(min(eighths,4),eighths)
                else:
                    note_len = random.randint(1,eighths)

            rest = ( random.randint(1,20) <= 2) and not ending
            if rest:
                nn = N('R',nl[note_len])
            elif harm:
                chord = []
                chord_len = random.randint(2,3)
                cn_idx = note_idx
                while chord_len >= 0 and cn_idx >= 0:
                    chord.append(scl[cn_idx])
                    chord_len -= 1
                    cn_idx -= 2
                nn = C(chord,nl[note_len])
            else:
                nn = N(scl[note_idx],nl[note_len])
            melody.append(nn)
            eighths -= nt[note_len]
            note_idx += note_dir
            if note_idx < 0:
                note_idx = 1
                note_dir = 1
            elif note_idx >= len(scl):
                note_idx = len(scl)-2
                note_dir = -1

            if delta_gen:
                note_dir = delta_gen.getDelta()
            elif not eighths:
                note_dir = -note_dir
        cidx += 1
    return((melody,note_idx,note_dir))
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="slides_sound.soundgen.load_music">
    <p>def <span class="ident">load_music</span>(</p><p>music_file)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-slides_sound.soundgen.load_music', this);">Show source &equiv;</a></p>
  <div id="source-slides_sound.soundgen.load_music" class="source">
    <pre><code>def load_music( music_file ):
    s = open(music_file,"r").read()
    return eval(s)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="slides_sound.soundgen.max_sample">
    <p>def <span class="ident">max_sample</span>(</p><p>sa)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-slides_sound.soundgen.max_sample', this);">Show source &equiv;</a></p>
  <div id="source-slides_sound.soundgen.max_sample" class="source">
    <pre><code>def max_sample( sa ):
    m = 0.0000001
    for s in sa:
        if math.fabs(s) > m:
            m = math.fabs(s)
    return m
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="slides_sound.soundgen.mix_sample">
    <p>def <span class="ident">mix_sample</span>(</p><p>sa, sb, max_amp=15386.0)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-slides_sound.soundgen.mix_sample', this);">Show source &equiv;</a></p>
  <div id="source-slides_sound.soundgen.mix_sample" class="source">
    <pre><code>def mix_sample( sa, sb, max_amp = global_max_amp):
    ua = unpack_sample(sa)
    ub = unpack_sample(sb)
    ss = sum_samples(ua,ub)
    mx = max_sample(ss)
    return pack_sample(scale_sample(ss,max_amp/mx))
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="slides_sound.soundgen.pack_sample">
    <p>def <span class="ident">pack_sample</span>(</p><p>s)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-slides_sound.soundgen.pack_sample', this);">Show source &equiv;</a></p>
  <div id="source-slides_sound.soundgen.pack_sample" class="source">
    <pre><code>def pack_sample( s ):
    sample = bytearray(len(s)*2)
    wave.struct.pack_into('%dh'%len(s),sample,0,*[int(sv) for sv in s])
    return sample
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="slides_sound.soundgen.play_song">
    <p>def <span class="ident">play_song</span>(</p><p>s, out_file=&#39;soundgen.wav&#39;)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-slides_sound.soundgen.play_song', this);">Show source &equiv;</a></p>
  <div id="source-slides_sound.soundgen.play_song" class="source">
    <pre><code>def play_song( s, out_file = "soundgen.wav" ):
    if verbose:
        print("Phrase measures",phrase_measures)
#    print "Synthesizing Chords"
#    chords = punch_chords(s)
#    chords = s.chords
#    print "chord eighths =",sum_eighths(chords)
#    chord_progression = gen_line( chords ,s.tempo, s.swing, "ff" )
#    save_sample(chord_progression,"chords.wav",1)
    if verbose:
        print("Synthesizing Melody")
        print("melody eighths =",sum_eighths(s.melody))
    melody_line = gen_line( s.melody,s.tempo,s.swing,"f",s.melody_voice)
    if debug:
        save_sample(melody_line,"melody.wav",1)
    melody_line = reverb(melody_line)
    if debug:
        save_sample(melody_line,"melodyrv.wav",1)

    if verbose:
        print("Synthesizing Bass")
        print("bass eighths = ",sum_eighths(s.rhythm))
    bass_line = gen_line( s.rhythm,s.tempo,s.swing,"f",s.rhythm_voice)
    if debug:
        save_sample(bass_line,"bass.wav",1)
    bass_line = reverb(bass_line)
    if debug:
        save_sample(bass_line,"bassrv.wav",1)

#    print "Mixing Chords and Bass"
#    chords_n_bass = mix_sample(chord_progression, bass_line)
#    save_sample(chords_n_bass,"chordsnbass.wav",1)
    if verbose:
        print("Balancing Channels")
    ls,rs = balance( bass_line, 0.60, 0.40, melody_line, 0.40, 0.60 )
    if verbose:
        print("Saving song")
    idx = 0
    out_len = min(len(ls),len(rs))
    output = bytearray(out_len*4)
    while idx < out_len:
        wave.struct.pack_into("BBBB",output,idx*4,ls[idx],ls[idx+1],rs[idx],rs[idx+1])
        idx += 2
    save_sample(output,out_file,2)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="slides_sound.soundgen.punch_chords">
    <p>def <span class="ident">punch_chords</span>(</p><p>song, transpose=0)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-slides_sound.soundgen.punch_chords', this);">Show source &equiv;</a></p>
  <div id="source-slides_sound.soundgen.punch_chords" class="source">
    <pre><code>def punch_chords( song, transpose = 0 ):
    phrase_eighths = value_to_eighths[song.beat] * song.measure * 4
    phrase_index = 0
    phrase = []
    for idx in range(0,3):
        eighths = phrase_eighths // 4
        while ( eighths > 0 ):
            note_len = min(eighths,random.choice([1,2,4]))
            if eighths < (phrase_eighths // 4) and (random.randint(1,10) <= 8):
                phrase.append(-note_len)
            else:
                phrase.append(note_len)
            eighths -= bass_times[note_len]
    if verbose:
        print("punch_chords:",phrase)
    line = []
    note_idx = 8
    note_dir = 1
    cidx = 0
    while cidx < len(song.chords):
        c = song.chords[cidx]
        root,octave,type = split_chord(c.name)
        cp = join_chord(root,octave+transpose,type)
        eighths = value_to_eighths[c.value]
        lay_out = False
        while ( eighths > 0 ):
            if phrase_index >= len(phrase):
                phrase_index = 0

            if phrase_index == 0:
                lay_out = ( random.randint(1,10) < 4 )
                if lay_out:
                    if verbose:
                        print("chords laying out")
                else:
                    if verbose:
                        print("chords playing")

            note_len = phrase[phrase_index]
            nn = cp
            if note_len < 0:
                note_len = -note_len
                nn = "R"

            if lay_out:
                nn = "R"
            note_len = min(eighths, note_len)
            line.append(C(nn,bass_note_lengths[note_len]))
            eighths -= bass_times[note_len]
            phrase_index += 1
        cidx += 1
    if verbose:
        print("punch_chords:",line)
    return line
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="slides_sound.soundgen.reverb">
    <p>def <span class="ident">reverb</span>(</p><p>sa, delay=0.05, sr=44100.0, max_amp=15386.0)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-slides_sound.soundgen.reverb', this);">Show source &equiv;</a></p>
  <div id="source-slides_sound.soundgen.reverb" class="source">
    <pre><code>def reverb( sa, delay = 0.05, sr = 44100.0, max_amp = global_max_amp ):
    delay_samples = int(sr*delay)

    ua = unpack_sample(sa)
    output = ua[:delay_samples]
    for idx in range(delay_samples,len(ua)):
        output.append(ua[idx]+ua[idx-delay_samples]*0.125+ua[idx-int(delay_samples*0.75)]*0.25+ua[idx-int(delay_samples*0.50)]*0.5+ua[idx-int(delay_samples*0.25)]*1.0)
    mx = max_sample(output)

    return pack_sample(scale_sample(output,max_amp/mx))
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="slides_sound.soundgen.save_sample">
    <p>def <span class="ident">save_sample</span>(</p><p>output, fname, channels)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-slides_sound.soundgen.save_sample', this);">Show source &equiv;</a></p>
  <div id="source-slides_sound.soundgen.save_sample" class="source">
    <pre><code>def save_sample ( output, fname, channels ):
    out_file = wave.open(fname,"w")
    out_file.setparams((channels,2,44100,len(output)//2,"NONE","noncompressed"))
    out_file.writeframes(output)
    out_file.close()
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="slides_sound.soundgen.scale_sample">
    <p>def <span class="ident">scale_sample</span>(</p><p>sa, scale)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-slides_sound.soundgen.scale_sample', this);">Show source &equiv;</a></p>
  <div id="source-slides_sound.soundgen.scale_sample" class="source">
    <pre><code>def scale_sample( sa, scale ):
    ss = []
    for s in sa:
        ss.append(s*scale)
    return ss
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="slides_sound.soundgen.set_debug">
    <p>def <span class="ident">set_debug</span>(</p><p>db)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-slides_sound.soundgen.set_debug', this);">Show source &equiv;</a></p>
  <div id="source-slides_sound.soundgen.set_debug" class="source">
    <pre><code>def set_debug( db ):
    global debug
    debug = db
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="slides_sound.soundgen.set_verbose">
    <p>def <span class="ident">set_verbose</span>(</p><p>vb)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-slides_sound.soundgen.set_verbose', this);">Show source &equiv;</a></p>
  <div id="source-slides_sound.soundgen.set_verbose" class="source">
    <pre><code>def set_verbose( vb ):
    global verbose
    verbose = vb
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="slides_sound.soundgen.smooth_decay">
    <p>def <span class="ident">smooth_decay</span>(</p><p>sample)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-slides_sound.soundgen.smooth_decay', this);">Show source &equiv;</a></p>
  <div id="source-slides_sound.soundgen.smooth_decay" class="source">
    <pre><code>def smooth_decay( sample ):
    us = unpack_sample(sample)
    quarter = len(us)//4
    scale = slope = 1.0 / float(quarter)
    idx = -quarter
    while idx < 0:
        us[idx] = us[idx] - us[idx]*scale
        scale = scale + slope
        idx += 1
    return pack_sample(us)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="slides_sound.soundgen.sum_eighths">
    <p>def <span class="ident">sum_eighths</span>(</p><p>line)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-slides_sound.soundgen.sum_eighths', this);">Show source &equiv;</a></p>
  <div id="source-slides_sound.soundgen.sum_eighths" class="source">
    <pre><code>def sum_eighths( line ):
    eighths = 0
    for s in line:
        eighths += value_to_eighths[s.value]
    return eighths
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="slides_sound.soundgen.sum_samples">
    <p>def <span class="ident">sum_samples</span>(</p><p>sa, sb)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-slides_sound.soundgen.sum_samples', this);">Show source &equiv;</a></p>
  <div id="source-slides_sound.soundgen.sum_samples" class="source">
    <pre><code>def sum_samples( sa, sb ):
    ss = []
    ll = max(len(sa), len(sb))
    for idx in range(ll):
        if idx < len(sa) and idx < len(sb):
            ss.append(sa[idx]+sb[idx])
        elif idx < len(sa):
            ss.append(sa[idx])
        elif idx < len(sb):
            ss.append(sb[idx])
    return ss
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="slides_sound.soundgen.unpack_sample">
    <p>def <span class="ident">unpack_sample</span>(</p><p>s)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-slides_sound.soundgen.unpack_sample', this);">Show source &equiv;</a></p>
  <div id="source-slides_sound.soundgen.unpack_sample" class="source">
    <pre><code>def unpack_sample( s ):
    sl = len(s)//2
    up = wave.struct.unpack_from('%dh'%sl,s,0)
    us = [float(sv) for sv in up]
    return us
</code></pre>
  </div>
</div>

  </div>
  

    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="slides_sound.soundgen.DeltaGenerator" class="name">class <span class="ident">DeltaGenerator</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-slides_sound.soundgen.DeltaGenerator', this);">Show source &equiv;</a></p>
  <div id="source-slides_sound.soundgen.DeltaGenerator" class="source">
    <pre><code>class DeltaGenerator:
    def __init__(self, deltas = [] ):
        self.deltas = deltas
        self.didx = 0

    def getDelta( self ):
        delta = 0
        if self.deltas:
            delta = self.deltas[self.didx]
            self.didx = self.didx + 1
            if self.didx >= len(self.deltas):
                self.didx = 0
        return delta
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#slides_sound.soundgen.DeltaGenerator">DeltaGenerator</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="slides_sound.soundgen.DeltaGenerator.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, deltas=[])</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-slides_sound.soundgen.DeltaGenerator.__init__', this);">Show source &equiv;</a></p>
  <div id="source-slides_sound.soundgen.DeltaGenerator.__init__" class="source">
    <pre><code>def __init__(self, deltas = [] ):
    self.deltas = deltas
    self.didx = 0
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="slides_sound.soundgen.DeltaGenerator.getDelta">
    <p>def <span class="ident">getDelta</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-slides_sound.soundgen.DeltaGenerator.getDelta', this);">Show source &equiv;</a></p>
  <div id="source-slides_sound.soundgen.DeltaGenerator.getDelta" class="source">
    <pre><code>def getDelta( self ):
    delta = 0
    if self.deltas:
        delta = self.deltas[self.didx]
        self.didx = self.didx + 1
        if self.didx >= len(self.deltas):
            self.didx = 0
    return delta
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="slides_sound.soundgen.DeltaGenerator.deltas" class="name">var <span class="ident">deltas</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="slides_sound.soundgen.DeltaGenerator.didx" class="name">var <span class="ident">didx</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
